<!DOCTYPE html>
<html lang="en-US" data-theme="light">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>c++ 面向对象 | Kim&#39;s Blog</title>
<noscript>开启Javascript是必要的</noscript>
<link rel="icon" type="image/x-icon" href="/img/logo.jpg">
<link rel="apple-touch-icon" href="/img/logo.jpg">
<meta name="apple-mobile-web-app-title" content="Kim&#39;s Blog">
<link rel="bookmark" href="/img/logo.jpg">
<link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/logo.jpg">
<meta name="description" content="Stay Hungry, Stay Foolish!">
<meta name="theme-color" content="#1C1C1F">
<link rel="stylesheet" href="/css/var.css">
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/custom.css">



<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    

<link rel="stylesheet" href="/lib/snackbar.min.css">


<script src="/lib/qrcode.min.js"></script>





<script>var GLOBALCONFIG = {"root":"/","runtime":"2022-12-12 00:00:00","lazyload":{"enable":false,"error":"/img/acrylic.png"},"hightlight":{"enable":false,"limit":200},"lightbox":true,"randomlinks":false,"lang":{"theme":{"dark":"Switched to dark mode","light":"Switched to light mode"},"copy":{"success":"Copied successfully","error":"Copied failed"},"backtop":"Back to top","time":{"recent":"Recent","yesterday":"Yesterday","berforeyesterday":"TDBY","daybefore":"Days ago","runtime":"days"},"sayhello":{"morning":"Good morning","noon":"Good noon","afternoon":"Good afternoon","night":"Good evening","goodnight":"Good night","iam":"! I am"},"search":{"empty":"No results found","hit":"Found ${query} results for you","placeholder":"Enter keywords to quickly search"}},"covercolor":false,"consolePlus":{"enable":true,"twikooUrl":null},"localsearch":{"preload":false,"path":"/search.xml"}};</script><script id="site-config">var PAGECONFIG = {"is_home":false,"is_post":true,"is_page":false,"page":false,"toc":true,"comment":false};</script>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body id="body">
        
        <div id="console" style="zoom: 1;" class="">
    <div class="close-btn" onclick="acrylic.hideConsole()" href="javascript:void(0);">
        <i class="fas fa-circle-xmark"></i>
    </div>
    
        <div class="console-card-group">
            <div class="console-card-group-left">
                <div class="console-card" id="card-newest-comments" onclick="acrylic.hideConsole()">
                    <div class="card-content">
                        <div class="author-content-item-tips">互动</div>
                        <div class="author-content-item-title">最新评论</div>
                    </div>
                    <div class="aside-list"></div>
                </div>
    
            </div>
            <div class="console-card-group-right">
                <div class="console-card tags" onclick="acrylic.hideConsole()">
                    <div class="card-content">
                        <div class="author-content-item-tips">标签</div>
                        <div class="author-content-item-title">寻找感兴趣的领域</div>
                    </div>
                    <div class="card-tag-cloud">
                        
                            <a href="/tags/c/" style="font-size: 0.8rem; color: #d3d3d3">c++<sup>2</sup></a>
                        
                            <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.8rem; color: #d3d3d3">编程语言<sup>2</sup></a>
                        
                    </div>
                </div>
                <div class="console-card history" onclick="acrylic.hideConsole()">
                    <ul class="card-archive-list">
    
     
        <li class="card-archive-list-item"><a class="card-archive-list-link" onclick="pjax.loadUrl('/archives/2023-06/')" data-pjax-state=""><span
            class="card-archive-list-date">2023-06</span>
            <div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span
                    class="card-archive-list-count-unit">篇</span></div>
            </a>
        </li>
        
</ul>

                </div>
            </div>
        </div>
    
    
    <div class="button-group">
        <div class="console-btn-item"> <a class="darkmode_switchbutton" onclick="acrylic.switchDarkMode()" title="显示模式切换"
                href="javascript:void(0);" rel="external nofollow" data-pjax-state=""><i class="fas fa-moon"
                    style="font-size: 1rem;"></i></a></div>
                    
            <div class="console-btn-item" id="consoleMusic" onclick="acrylic.musicToggle()" title="音乐开关"><a class="music-switch"><i class="fas fa-music"></i></a></div>
        
    </div>
    <div class="console-mask" onclick="acrylic.hideConsole()" href="javascript:void(0);" rel="external nofollow"></div>
</div>
        <div id="sidebar" style="zoom: 1;">
    <div id="menu-mask" style="display: none;"></div>
    <div id="sidebar-menus" class>
        <span class="sidebar-menu-item-title">功能</span>
        <div class="sidebar-menu-item">
            <a class="darkmode_switchbutton menu-child" onclick="acrylic.switchDarkMode()" title="显示模式切换"
                href="javascript:void(0);" rel="external nofollow">
                <i class="fas fa-moon" style="font-size: 1rem;"></i>
                <span>显示模式</span>
            </a>
        </div>
        
            <div class="back-menu-list-groups">
    
  </div>
  
        
        <div class="menus_items">
    
        <div class="menus_item">
            
                <a class="site-page" href="javascript:void(0);" rel="external nofollow">
                    <span> 文库</span>
                </a>
                <ul class="menus_item_child">
                    
                        <li>
                            <a class="site-page child" href="/archives/">
                                <i class="fas fa-box-archive"></i>
                                <span> 文章列表</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/categories/">
                                <i class="fas fa-cube"></i>
                                <span> 全部分类</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/tags/">
                                <i class="fas fa-tags"></i>
                                <span> 全部标签</span>
                            </a>
                        </li>
                    
                </ul>
             
        </div>
    
        <div class="menus_item">
            
                <a class="site-page" href="javascript:void(0);" rel="external nofollow">
                    <span> 友链</span>
                </a>
                <ul class="menus_item_child">
                    
                        <li>
                            <a class="site-page child" href="/fcircle/">
                                <i class="fas fa-fish-fins"></i>
                                <span> 友链鱼塘</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/links/">
                                <i class="fas fa-user-group"></i>
                                <span> 友情链接</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="javascript:travelling()">
                                <i class="fas fa-bus"></i>
                                <span> 宝藏博主</span>
                            </a>
                        </li>
                    
                </ul>
             
        </div>
    
        <div class="menus_item">
            
                <a class="site-page not-child" target="_blank" href="https://github.com/freelancelwj7" rel="external nofollow noopener">
                    <span> 仓库</span>
                </a>
             
        </div>
    
</div>
        <span class="sidebar-menu-item-title">标签</span>
        <div class="card-widget card-tags card-archives card-webinfo card-allinfo">
            <div class="item-headline">
                <i class="fas fa-tags"></i>
                <span>标签</span>
            </div>
            <div class="card-tag-cloud">
                
                    <a href="/tags/c/" style="font-size: 1em; color: #d3d3d3">c++
                        <sup>2</sup>
                    </a>
                
                    <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1em; color: #d3d3d3">编程语言
                        <sup>2</sup>
                    </a>
                
            </div>
        </div>
    </div>
</div>    
        
            <div class="post" id="body-wrap">
                <header class="post-bg" id="page-header">
    <nav id="nav" class="show">
    <div id="nav-group">
        <div id="blog_name">
            
                <div class="back-home-button" tabindex="-1">
                    <i class="back-home-button-icon fas fa-grip-vertical"></i>
                    <div class="back-menu-list-groups">
    
  </div>
  
                </div>
            
            <a id="site-name" href="/" title="返回博客主页">
                    
                        <span class="heoicon">Kim</span>
                    
            </a>
        </div>
        <div id="page-name-mask">
            <div id="page-name">
                <a id="page-name-text" onclick="acrylic.toTop()">c++ 面向对象</a>
            </div>
        </div>
        <div id="menus">
            <div class="menus_items">
    
        <div class="menus_item">
            
                <a class="site-page" href="javascript:void(0);" rel="external nofollow">
                    <span> 文库</span>
                </a>
                <ul class="menus_item_child">
                    
                        <li>
                            <a class="site-page child" href="/archives/">
                                <i class="fas fa-box-archive"></i>
                                <span> 文章列表</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/categories/">
                                <i class="fas fa-cube"></i>
                                <span> 全部分类</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/tags/">
                                <i class="fas fa-tags"></i>
                                <span> 全部标签</span>
                            </a>
                        </li>
                    
                </ul>
             
        </div>
    
        <div class="menus_item">
            
                <a class="site-page" href="javascript:void(0);" rel="external nofollow">
                    <span> 友链</span>
                </a>
                <ul class="menus_item_child">
                    
                        <li>
                            <a class="site-page child" href="/fcircle/">
                                <i class="fas fa-fish-fins"></i>
                                <span> 友链鱼塘</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/links/">
                                <i class="fas fa-user-group"></i>
                                <span> 友情链接</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="javascript:travelling()">
                                <i class="fas fa-bus"></i>
                                <span> 宝藏博主</span>
                            </a>
                        </li>
                    
                </ul>
             
        </div>
    
        <div class="menus_item">
            
                <a class="site-page not-child" target="_blank" href="https://github.com/freelancelwj7" rel="external nofollow noopener">
                    <span> 仓库</span>
                </a>
             
        </div>
    
</div>
        </div>
        <!-- <div id="nav-left">
            <div id="fps-group">
                <div id="fps">145</div><span class="fpsText">FPS</span>
            </div>
        </div> -->
        <div id="nav-right">
            
    <div class="nav-button only-home" id="travellings_button">
        <a class="site-page"  target="_blank" rel="noopener external nofollow" href="https://www.travellings.cn/go.html" title="开往-友链接力"  width="120">
            <i class="fa-solid fa-train-subway" style="font-size: 1rem;"></i>
        </a>
    </div>


    <div class="nav-button" id="randomPost_button">
        <a class="site-page" onclick="toRandomPost()"
            title="随机前往一个文章">
            <i class="fas fa-shuffle" style="font-size: 1rem;"></i>
        </a>
    </div>


    <div class="nav-button" id="search-button">
        <a class="site-page social-icon search" title="站内搜索"
            href="javascript:void(0);" rel="external nofollow">
            <i class="fas fa-magnifying-glass" style="font-size: 1rem;"></i>
        </a>
    </div>


    <div class="nav-button" id="nav-console">
        <a class="console_switchbutton" onclick="acrylic.showConsole()"
        title="显示中控台" href="javascript:void(0);" rel="external nofollow">
        <i class="fas fa-bars-progress" style="font-size: 1rem;"></i>
        </a>
    </div>

<div class="nav-button" id="nav-totop" onclick="acrylic.toTop()">
    <a class="totopbtn">
        <i class="fas fa-arrow-up"></i>
        <span id="percent">0</span>
    </a>
</div>
<div id="toggle-menu">
    <a class="site-page">
        <i class="fas fa-bars fa-fw" style="font-size: 1rem;"></i>
    </a>
</div>
        </div>
    </div>
</nav>
    
        <div class="coverdiv" id="coverdiv">
    <img id="post-cover" class="nolazyload" src="/img/cpplogo.jpg" alt="cover">
</div>
<div id="post-info">
    <div id="post-firstinfo">
        <div class="meta-firstline">
            <a class="post-meta-original" title="该文章为原创文章，注意版权协议">
                原创
            </a>
            
            <span class="post-meta-categories">
                
                    <a class="post-meta-categories" href="/categories/c/">c++</a>
                
            </span>
            
            <div class="tag_share">
                <div class="post-meta__tag-list">
                    
                        <a class="post-meta__tags" href="/tags/c/">
                            <span class="tags-punctuation">#</span>
                            <span class="tags-name">c++</span>
                        </a>
                    
                        <a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
                            <span class="tags-punctuation">#</span>
                            <span class="tags-name">编程语言</span>
                        </a>
                    
                </div>
            </div>
        </div>
    </div>
    <h1 class="post-title">c++ 面向对象</h1>
    <div id="post-meta">
        <div class="meta-secondline">
            <span class="post-meta-date" title="发布于">
                <i class="post-meta-icon fa-fw fas fa-calendar"></i>
                <time datetime="2023-06-10T11:48:28+08:00"></time>
            </span>
            
                <span class="post-meta-date" title="更新于">
                    <i class="post-meta-icon fa-solid fa-clock-rotate-left"></i>
                    <time datetime="2023-06-10T12:10:46+08:00"></time>
                </span>
            
            
                <span class="post-meta-position" title="作者IP归属地为青岛">
                    <i class="fas fa-location-dot post-meta-icon"></i>
                    <span>青岛</span>
                </span>
            
            
                
                    <span class="post-meta-wordcount">
                        <i class="fas fa-file-word fa-fw post-meta-icon" title="文章字数"></i>
                        <span class="word-count">14.1k</span>
                    </span>
                
                
                    <span class="post-meta-time">
                        <i class="fas fa-clock post-meta-icon" title="阅读耗时"></i>
                        <span>59 min</span>
                    </span>
                
            
            
                
        </div>
    </div>
</div>
<section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg"
    xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
    <defs>
        <path id="gentle-wave"
            d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path>
    </defs>
    <g class="parallax">
        <use href="#gentle-wave" x="48" y="0"></use>
        <use href="#gentle-wave" x="48" y="3"></use>
        <use href="#gentle-wave" x="48" y="5"></use>
        <use href="#gentle-wave" x="48" y="7"></use>
    </g>
</svg>
</section>

        
</header>
                <main class="layout" id="content-inner">
    <div id="post">
        <article class="post-content" id="article-container">
            <h1 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h1><p>C++ 程序在执行时，将内存大方向划分为 4 个区域</p>
<ul>
<li>代码区：存放函数体​的二进制代码，由操作系统进行管理</li>
<li>全局区：存放全局变量和静态变量以及常量（字符串常量、const修饰的常量）</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<h2 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h2><p>在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域：</p>
<p><strong>代码区：</strong></p>
<p>存放 CPU 执行的机器指令，代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p><strong>全局区：</strong></p>
<p>该区域的数据在程序结束后由操作系统释放</p>
<h2 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h2><p><strong>栈区：</strong></p>
<p>由编译器自动分配释放，存放函数的参数值，局部变量等<br>‍<br><strong>注意：不要返回局部变量的地址</strong>，栈区开辟的数据由编译器自动释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆区：</strong></p>
<p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>
<p>主要利用<strong>​ new ​</strong>在堆区开辟内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆区开辟的数据，由程序员手动开辟，手动释放，利用 delete 操作符释放</p>
<p>利用 new 创建的数据，会返回该数据对应的类型的指针</p>
<h2 id="1-3-new-实现动态内存分配"><a href="#1-3-new-实现动态内存分配" class="headerlink" title="1.3 new 实现动态内存分配"></a>1.3 new 实现动态内存分配</h2><ul>
<li><p>第一种用法：分配一个变量 <code>P = new T;</code>​</p>
</li>
<li><p>参数解释：T 是任意类型名，P 是 T* 类型的指针</p>
</li>
<li><p>作用：动态分配一片大小为 sizeof(T) 字节的内存空间，并将该内存空间的起始地址赋值给 P</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pn;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*pn = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>第二种用法：分配一个数组 <code>P = new T[N];</code>​</li>
<li>参数解释：T 是任意类型名，P 是 T* 类型的指针，N 是要分配的数组元素的个数，可以是整型表达式</li>
<li>作用：动态分配一片大小为 N*sizeof(T) 字节的内存空间，并将该内存空间的起始地址赋值给 P</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pn;</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="type">int</span>[i * <span class="number">20</span>];</span><br><span class="line">pn[<span class="number">0</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>用 new 动态分配的内存空间，一定要用 delete 释放，否则会一直占用空间，从而可能会导致操作系统或其他应用程序的运行的内存空间都不够</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> 指针;  <span class="comment">// 该指针必须指向 new 出来的空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*p = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">// 不能多次 delete</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] 指针;  <span class="comment">// 该指针必须指向 new 出来的空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>


<h1 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h1><p>作用： 给变量起别名</p>
<p>语法： <code>数据类型&amp; 别名 = 原名</code>​​​</p>
<p>‍</p>
<ul>
<li>指针和引用的补充或者注意事项：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 等价 int* const b = &amp;a;这里也说明了为啥引用一旦初始化之后，就不能再改变了</span></span><br><span class="line"><span class="type">int</span>&amp; b = a; </span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span>;  <span class="comment">// 此时，a 和 b 的值都是 100</span></span><br><span class="line">b = <span class="number">200</span>;  <span class="comment">// 此时，a 和 b 的值都是 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; y = x;  <span class="comment">// 注意这里的 const 修饰的 y，而不是 x ！！！</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">9</span>;  <span class="comment">// 这里仍然可以修改 x 的值，x 和 y 的值都是 9</span></span><br><span class="line"><span class="comment">// y = 99;  // 错误!!因为是 const 修饰的 y</span></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针复习</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ptr = &amp;n;</span><br><span class="line">*ptr = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定 p，既不能修改 p 的指向，也不能修改 p 指向的值，这里说指向的值，是不能用 *p 修改 n 的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;n;</span><br><span class="line">n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// *ptr = 9;  // 错误!!表达式必须是可以修改的左值</span></span><br></pre></td></tr></table></figure>


<p>特点：</p>
<ul>
<li><p>引用必须初始化</p>
</li>
<li><p>引用在初始化后，不可以改变（因为引用的本质其实是伪指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rat;</span><br><span class="line"><span class="type">int</span>&amp; rodent = rat;  <span class="comment">// rodent 和 *ptr 是等价的</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;rat;  <span class="comment">// 指针常量，不能改变指针的指向，但是可以改变指向的值</span></span><br></pre></td></tr></table></figure></li>
<li><p>当形参为 const 引用与实参不匹配时，c++ 将生成临时变量，则其行为类似于按值传递，为了确保原始数据不被修改，将使用临时变量存值，以下两种情况会生成临时变量：</p>
<ol>
<li>实参类型正确，但不是左值（可被引用的数据对象，即可通过地址访问的对象）</li>
<li>实参类型不正确，但可以转为正确的类型</li>
</ol>
</li>
<li><p>如果声明将引用指定为 const，c++ 将在必要的时候生成临时变量，但是 const 修饰的引用变量，之后是不可以更改的</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a*a*a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> side = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">long</span> edge = <span class="number">5L</span>;</span><br><span class="line"><span class="type">double</span> lens[<span class="number">4</span>] = &#123;<span class="number">2.0</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">12.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c1 = <span class="built_in">refcube</span>(side);  <span class="comment">// a 是 side</span></span><br><span class="line"><span class="type">double</span> c2 = <span class="built_in">refcube</span>(lens[<span class="number">2</span>]);  <span class="comment">// a 是 lens[2]</span></span><br><span class="line"><span class="type">double</span> c3 = <span class="built_in">refcube</span>(edge);  <span class="comment">// 虽然 c3 的结果是 125，但是 a 是临时变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>现在，如果是普通的引用修饰形参的话，实参与形参类型不匹配，是会报错的，不像之前，会有一个临时变量的转换过程</li>
<li>这里补充一下知识点：非左值包括字面常量（字符串常量除外，他们有自己的地址）和包含多项的表达式</li>
<li>函数传参时，引用可以让形参修饰实参，可以简化指针修改实参</li>
<li>引用必须是要在栈或堆上的变量，不能直接引用常量，如 <code>int&amp; a = 10;</code>​​ 这里说的不能直接引用常量是因为，常量在内存中，是临时地址，随时都能被释放</li>
</ul>
<blockquote>
<p><strong>总结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更简洁</strong></p>
</blockquote>
<hr>
<ul>
<li>引用是可以作为函数的返回值</li>
</ul>
<p>注意：不要返回局部变量引用</p>
<p>用法：函数调用作为左值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;  <span class="comment">// ref = 10</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;  // test01 返回的是局部变量，函数调用完之后，a 的内存被释放了，因此 ref 也被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 20</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 20</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 1000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 1000</span></span><br><span class="line">   </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引用的本质在 c++ 内部实现是一个<strong>指针常量</strong>，但是所有的指针操作编译器都帮我们做了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>;  <span class="comment">// ref 是引用，转换为 *ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>;  <span class="comment">// 内部发现 ref 是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常量引用主要用来修饰形参，防止误操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// v += 10;  // 因为是 const 修饰，所以不能修改 v 的值</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">// 但是如果是 const 修饰的引用，编译器优化代码 int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ref = 100;  // 加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>‍<br>补充：</p>
<ul>
<li>不能把常量指针赋值给非常量指针，反过来可以；不能把常量引用赋值非常量引用，反过来可以</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; x = a;</span><br><span class="line"><span class="comment">// int&amp; y = x;  // 这里会报错，因为将 int&amp; 类型的引用绑定到 const int&amp; 类型的初始值设定时，限定符会被丢弃</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; m = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; n = m;  <span class="comment">// 这里是可以正常编译的</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span>;  <span class="comment">// b m n 的值都是 20</span></span><br><span class="line">m = <span class="number">49</span>;  <span class="comment">// b m n 的值都是 49</span></span><br><span class="line"><span class="comment">// n = 99;  // 错误!!表达式必须是可以修改的左值</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针同上，但是也可以通过强制类型转换的方式，把常量指针赋值给非常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1;</span><br><span class="line"><span class="type">int</span>* p2;</span><br><span class="line"></span><br><span class="line">p1 = p2;  <span class="comment">// ok</span></span><br><span class="line">p2 = p1;  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">p2 = (<span class="type">int</span>*) p1;  <span class="comment">// ok，强制转换</span></span><br></pre></td></tr></table></figure>


<p><strong>常量成员函数补充：</strong></p>
<ul>
<li><p>在类的成员函数声明后面加 const 关键字，则该成员函数是常量成员函数</p>
</li>
<li><p>常量成员函数执行期间，不应该修改其作用的对象（不能修改成员变量的值，静态成员变量除外；也不能调用同类的非常量成员函数 [因为可能会更改]，静态成员函数除外）</p>
</li>
<li><p>两个成员函数，名字和参数一样，但是一个是 const，一个不是，算重载</p>
</li>
</ul>
<hr>
<h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h1><h2 id="3-1-普通函数"><a href="#3-1-普通函数" class="headerlink" title="3.1 普通函数"></a>3.1 普通函数</h2><ul>
<li><p>函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
</li>
<li><p>函数参数可缺省的目的在于提高程序的可扩充性</p>
</li>
</ul>
<p>语法： <code>返回值类型 函数名 (数据类型)&#123;&#125;</code>​​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);  <span class="comment">// 占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重载作用：函数名可以相同，提高复用性</p>
<p>函数重载满足条件：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名相同</li>
<li>函数参数类型不同或者个数不同或者顺序不同</li>
</ul>
<p>注意:  函数的返回值不可以作为函数重载的条件</p>
<p>函数重载注意事项：</p>
<ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span>  <span class="comment">// int&amp; a = 10; 错误！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int&amp; a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const int&amp; a = 10; 注意这个是合法的！</span></span><br><span class="line"><span class="comment">// 相当于 int tmp = 10; const int&amp; a = tmp;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int&amp; a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数重载碰到函数默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a);  <span class="comment">// 调用无 const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);  <span class="comment">// 调用有 const</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// func2(10);  // 碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-内联函数"><a href="#3-2-内联函数" class="headerlink" title="3.2 内联函数"></a>3.2 内联函数</h2><ul>
<li><p>函数调用是有时间开销的，如果函数本身只有几条语句，执行的非常快。相比之下，调用函数产生的开销就会大很多</p>
</li>
<li><p>为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，时将整个函数的代码插入到调用语句处，而不会产生调用函数的语句</p>
</li>
<li><p>在函数定义前加 inline 关键字，即可定义内联函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h1><p>‍<br>结构化程序设计：程序 &#x3D; 数据结构 + 算法</p>
<p>面向对象的程序 &#x3D; 类 + 类 + … + 类</p>
<p>设计程序的过程，就是设计类的过程！</p>
<p>‍</p>
<p>面向对象的程序设计方法：</p>
<ul>
<li><p>将某类客观事物共同特点（属性）归纳出来，形成一个数据结构</p>
</li>
<li><p>将这类事物能进行的行为也归纳出来，形成一个函数，这些函数可以用来操作数据结构（这一步叫“抽象”）</p>
</li>
<li><p>类的成员函数和类的定义分开写（类外的定义需要使用 :: 运算符限定作用域）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> w, h;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Area</span><span class="params">()</span></span>;  <span class="comment">// 声明成员函数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Perimeter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> w_, <span class="type">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRectangle::Area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRectangle::Perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * (w + h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::Init</span><span class="params">(<span class="type">int</span> w_, <span class="type">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	w = w_; h = h_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>C++ 面向对象的三大特性为：<strong>封装、继承、多态</strong></p>
<p>C++ 认为万事万物皆对象，对象上有属性和行为</p>
<h2 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h2><p>‍</p>
<ul>
<li><p>类中的变量称为成员变量，类中的函数称为成员函数，类定义出来的变量，也称为类的实例，也是“对象”</p>
</li>
<li><p>每个对象各有自己的存储空间，一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个类，从而使得数据结构和操作该数据结构的算法呈现出紧密关系，这就是“封装”</p>
</li>
</ul>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现为事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p>访问权限有三种：</p>
<ol>
<li>public         公共权限    类内可以访问  类外可以访问</li>
<li>protected   保护权限    类内可以访问  类外不可以访问</li>
<li>private        私有权限    类内可以访问  类外不可以访问</li>
</ol>
<p>设置私有成员的机制，叫“隐藏”，隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，以后需要对成员变量的类型等属性修改后，只修改成员函数即可。否则，所有直接访问成员变量的语句都需要修改</p>
<p>在类的成员函数内部，能访问：</p>
<ul>
<li>当前对象的全部属性、函数</li>
<li>同类其他对象的全部属性、函数</li>
</ul>
<p>在类的成员函数以外的地方，只能访问该类对象的公有成员</p>
<p>在 C++ 中 struct 和 class 唯一的区别就在于默认的访问权限不同</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<h2 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h2><p>C++ 中的面向对象来源于生活，每个对象都有初始设置以及对象销毁前的清理数据</p>
<hr>
<h3 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h3><p>对象的初始化和清理是两个非常重要的安全问题</p>
<p>c++ 利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>
<p>编译器提供的构造函数和析构函数是空实现</p>
<ul>
<li>构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</li>
<li>析构函数：在对象销毁前系统自动调用，执行一些清理工作</li>
</ul>
<p>构造函数语法：<code>类名()&#123;&#125;</code>​​</p>
<ol>
<li>构造函数，没有返回值也不写 void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造函数，无须手动调用，而且只会调用一次</li>
</ol>
<p>析构函数语法： <code>~类名()&#123;&#125;</code>​​</p>
<ol>
<li>析构函数，没有返回值也不写 void</li>
<li>函数名称与类名相同，在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li>
</ol>
<p>析构函数的两种分类方式：</p>
<ul>
<li>按参数分为： 有参构造和无参构造（默认）</li>
<li>按类型分为： 普通构造和拷贝构造</li>
</ul>
<p>析构函数的三种调用方式：</p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐式转换法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造函数分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;  <span class="comment">// 限定拷贝的时候，不能更改实参</span></span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、构造函数的调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;  <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.1 括号法（常用）</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Person p2();  // 注意1：调用无参构造函数不能加括号，否则编译器认为这是函数声明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">// Person(10);  // 单独写就是匿名对象，当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意2：这里不要利用拷贝构造函数初始化匿名对象，编译器会认为是对象声明</span></span><br><span class="line">	<span class="comment">// Person(p9);  // Person(p9) == Person p9;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>;  <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4;  <span class="comment">// Person p5 = Person(p4);  // 拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Person p5(p4);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>C++ 中拷贝构造函数调用时机通常有三种情况：</p>
<ul>
<li>用一个对象去初始化同类的另一个对象</li>
<li>如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的拷贝构造函数将被调用</li>
<li>如果函数的返回值是类 A 的对象，则函数返回时，A 的拷贝改造函数被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// p 对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man;  <span class="comment">// 拷贝构造</span></span><br><span class="line">	<span class="comment">// 隐式转换法</span></span><br><span class="line">	<span class="comment">// Person newman3 = man;  // 不是调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">// 相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;  <span class="comment">// 无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;  <span class="comment">// 局部对象在 doWork2() 作用完后，随即被释放</span></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)&amp;p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意这里返回 p1 是可以的，因为他在这里创建了一个副本，这个副本指的是拷贝构造函数产生的对象，生命周期要看它被使用到什么时候！只有返回引用和指针类型的数据才会报错</span></span><br><span class="line">	<span class="keyword">return</span> p1;  <span class="comment">// 这里返回的不是 p1 本身，而是创建一个 p1 副本返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，编译器至少给一个类添加 3 个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则：</p>
<ul>
<li>如果用户定义有参构造函数，c++ 不再提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，c++ 不再提供其他构造函数<br>‍</li>
</ul>
<p>注意：构造函数知识点补充</p>
<ol>
<li>如果自定义了有参构造函数，那么就不能再使用无参构造函数定义变量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	real = r, imag = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Complex c1;  <span class="comment">// error，缺少构造函数的参数</span></span><br><span class="line">	Complex* pc = <span class="keyword">new</span> Complex;  <span class="comment">// error，缺少构造函数的参数</span></span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>;  <span class="comment">// OK</span></span><br><span class="line">	Complex* pc = <span class="keyword">new</span> Complex;  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造函数在数组中的使用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSample</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSample</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor 1 Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CSample</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		x = n;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor 2 Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSample array[<span class="number">2</span>];  <span class="comment">// 输出两次 Constructor 1 Called</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	CSample array2[<span class="number">2</span>] = &#123; <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;  <span class="comment">// 输出两次 Constructor 2 Called</span></span><br><span class="line"></span><br><span class="line">	CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;  <span class="comment">// Constructor 2 Called，Constructor 1 Called</span></span><br><span class="line"></span><br><span class="line">	CSample* array4 = <span class="keyword">new</span> CSample[<span class="number">2</span>];  <span class="comment">// 输出两次 Constructor 1 Called</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] array4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>补充：</strong></p>
<p><strong>01 拷贝构造函数：</strong></p>
<ul>
<li>只有一个参数，即对同类对象的引用</li>
<li>形如 X::X( X&amp; )或 X::X( const X&amp; )，二者选一，注意参数必须是引用！后者能以常量对象作为参数</li>
<li>如果没有定义拷贝构造函数，那么编译器生成默认复制构造函数，默认的拷贝构造函数完成复制功能</li>
</ul>
<p>注意：</p>
<ul>
<li>对象间赋值并不导致拷贝构造函数被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">CMyclass</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">CMyclass</span>(CMyclass&amp; c) &#123;</span><br><span class="line">		n = <span class="number">2</span> * c.n;  <span class="comment">// 拷贝构造函数一般不这么做，这里只是为了举例子</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CMyclass c1, c2;</span><br><span class="line">	c1.n = <span class="number">5</span>;</span><br><span class="line">	c2 = c1;  <span class="comment">// 赋值语句，不是初始化语句，因此这里不会调用拷贝构造函数</span></span><br><span class="line">	<span class="function">CMyclass <span class="title">c3</span><span class="params">(c1)</span></span>;  <span class="comment">// 会调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c2.n=&quot;</span> &lt;&lt; c2.n &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c3.n=&quot;</span> &lt;&lt; c3.n &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍<br><strong>02 常量引用参数的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(CMyclass obj_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的函数，调用时生成形参会引发拷贝构造函数调用，开销大。因此，考虑使用 CMyclass&amp; 引用类型作为参数</li>
<li>如果希望实参的值在函数中不被改变，可以加上 const 关键字</li>
</ul>
<p><strong>03 类型转换构造函数</strong></p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换</li>
<li>只有一个参数，而且不是拷贝构造函数的构造函数，一般就可以看作是转换构造函数</li>
<li>当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> real, imag;</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> i)  <span class="comment">// 类型转换构造函数，如果碰到类型不匹配的，那么会生成临时变量来接收</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;IntConstructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">		real = i;</span><br><span class="line">		imag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) &#123; real = r; imag = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">	Complex c2 = <span class="number">12</span>;</span><br><span class="line">	<span class="comment">// 因为这里直接赋值的话，类型是不匹配的。9 被自动转为临时 Complex 对象</span></span><br><span class="line">	c1 = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c1.real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; c1.imag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>04 析构函数和数组</strong></p>
<ul>
<li>对象数组声明周期结束时，对象数组的每个元素的析构函数都会被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ctest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Ctest</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ctest array[<span class="number">2</span>];  <span class="comment">// 输出两次 destructor called</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;End main&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<p><strong>05 析构函数和运算符 delete</strong></p>
<ul>
<li>delete 运算导致析构函数调用</li>
<li>如果 new 一个对象数组，用 delete 释放时应该写 []，否则只 delete 一个对象（调用一次析构函数）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctest* pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest;  <span class="comment">// 构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;  <span class="comment">// 析构函数调用</span></span><br><span class="line">------------------------------------------</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>];  <span class="comment">// 调用 3 次构造函数</span></span><br><span class="line"><span class="keyword">delete</span>[] pTest;  <span class="comment">// 调用 3 次析构函数</span></span><br></pre></td></tr></table></figure>


<p><strong>06 析构函数在对象作为函数返回值后被调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyclass obj;  <span class="comment">// 全局函数变量，整个程序结束时，也会调用析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的形参被传入参数时，调用 CMyclass 的构造函数，当参数对象消亡，也会调用析构函数</span></span><br><span class="line"><span class="function">CMyclass <span class="title">fun</span><span class="params">(CMyclass sobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里注意 2 个点</span></span><br><span class="line">	<span class="comment">// 1.这里生成返回的临时对象</span></span><br><span class="line">	<span class="keyword">return</span> sobj;  <span class="comment">// 函数调用返回时，返回的是生成的临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 函数调用的返回值（临时对象）被用过后，该临时对象析构函数被调用</span></span><br><span class="line">	<span class="comment">// 这里是用临时对象给 obj 赋值</span></span><br><span class="line">	<span class="comment">// 2.临时对象的生命周期在执行完下行语句后消亡</span></span><br><span class="line">	obj = <span class="built_in">fun</span>(obj);  <span class="comment">// 输出 3 次 destructor</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>07 构造函数和析构函数的调用时机</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CMyclass</span>(<span class="type">int</span> i)  <span class="comment">// 类型转换构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		id = i;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;id = &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;id = &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; destructed&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CMyclass <span class="title">d1</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">// 因为这里有全局变量，所以 d1 调用构造函数比 main 中的还早</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">static</span> CMyclass <span class="title">d2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">CMyclass <span class="title">d3</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 程序执行输出结果</span></span><br><span class="line"><span class="comment">	id = 1 constructed</span></span><br><span class="line"><span class="comment">	id = 4 constructed</span></span><br><span class="line"><span class="comment">	id = 6 constructed</span></span><br><span class="line"><span class="comment">	id = 6 destructed</span></span><br><span class="line"><span class="comment">	main</span></span><br><span class="line"><span class="comment">	id = 5 constructed</span></span><br><span class="line"><span class="comment">	id = 5 destructed</span></span><br><span class="line"><span class="comment">	id = 2 constructed</span></span><br><span class="line"><span class="comment">	id = 3 constructed</span></span><br><span class="line"><span class="comment">	func</span></span><br><span class="line"><span class="comment">	id = 3 destructed</span></span><br><span class="line"><span class="comment">	main ends！</span></span><br><span class="line"><span class="comment">	id = 6 destructed</span></span><br><span class="line"><span class="comment">	id = 2 destructed</span></span><br><span class="line"><span class="comment">	id = 1 destructed</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function">CMyclass <span class="title">d4</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	d4 = <span class="number">6</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;<span class="function">CMyclass <span class="title">d5</span><span class="params">(<span class="number">5</span>)</span></span>; &#125;  <span class="comment">// 局部变量，遇到有大括号后，变量使用结束</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main ends！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-2-2-深拷贝与浅拷贝"><a href="#4-2-2-深拷贝与浅拷贝" class="headerlink" title="4.2.2 深拷贝与浅拷贝"></a>4.2.2 深拷贝与浅拷贝</h3><p>浅拷贝：引用做函数返回值，会带来堆区的内存重复释放（一般是在调用构造函数有时产生的问题）</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义拷贝构造函数，解决浅拷贝带来的问题</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person 拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		<span class="comment">// m_Height = p.m_height;  // 编译器默认写的浅拷贝</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);  <span class="comment">// 这里要加括号，是固定用法，记住就行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">			m_height = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;  <span class="comment">// 指针变量存放在栈，指针指向的值存放在堆中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;  <span class="comment">// 因为 m_height 是指针变量，所以，*m_height 的值被存放在堆中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为 p1 和 p2 是在栈中存储的，所以存储的时候，是先存储 p1 再存储 p2</span></span><br><span class="line">	<span class="comment">// 因此在释放（调用析构函数）的时候，先释放 p2 再释放 p1</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">// 拷贝构造函数，是浅拷贝。所以，p1 和 p2 的 m_height 指向的是同一块内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：这里用指针，是为了更好地突出深拷贝和浅拷贝面临的问题</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-2-3-初始化列表"><a href="#4-2-3-初始化列表" class="headerlink" title="4.2.3 初始化列表"></a>4.2.3 初始化列表</h3><p>作用：用来初始化属性</p>
<p>语法：<code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code>​​​</p>
<p>‍<br>成员对象和封闭类：有成员对象的类叫封闭（enclosing）类</p>
<h2 id="‍"><a href="#‍" class="headerlink" title="‍"></a>‍<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c): <span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="4-2-4-类对象作为类成员"><a href="#4-2-4-类对象作为类成员" class="headerlink" title="4.2.4 类对象作为类成员"></a>4.2.4 类对象作为类成员</h3><p>对象成员：类中的成员是另一个类的对象。B 类中有对象 A 作为成员，A 为对象成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建 B 对象时，构造的顺序是：先调用对象成员（A）的构造函数，再调用本类构造；析构顺序相反</p>
<p>封闭类的复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(A &amp;a) &#123; cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; A a; &#125;;  <span class="comment">// 既有无参构造函数，也有拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*输出</span></span><br><span class="line"><span class="comment">	default</span></span><br><span class="line"><span class="comment">	copy*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 说明 b2.a 是用类 A 的拷贝构造函数初始化的。而且调用拷贝构造函数时的实参就是 b1.a</span></span><br><span class="line">	B b1;  <span class="comment">// 这里输出的是 default</span></span><br><span class="line">	<span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;  <span class="comment">// 此时，拷贝构造函数不是简单地把 b1 拷贝给 b2，是用类 A 的拷贝构造函数初始化的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-2-5-静态成员"><a href="#4-2-5-静态成员" class="headerlink" title="4.2.5 静态成员"></a>4.2.5 静态成员</h3><ul>
<li><p>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>
</li>
<li><p>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享</p>
</li>
<li><p>sizeof 不会计算静态成员变量</p>
</li>
<li><p>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象；因此，静态成员不需要通过对象就能访问<br>‍</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.类名::成员名</span></span><br><span class="line">CRectangle::<span class="built_in">PrintTotal</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对象名.成员名</span></span><br><span class="line">CRectangle r;</span><br><span class="line">r.<span class="built_in">PrintTotal</span>();  <span class="comment">// 这里要注意，PrintTotal 并不是作用在 r 上的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.指针-&gt;成员名</span></span><br><span class="line">CRectangle* p = &amp;r;</span><br><span class="line">p-&gt;<span class="built_in">PrintTotal</span>();  <span class="comment">// 这里要注意，PrintTotal 并不是作用在 p 上的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.引用.成员名</span></span><br><span class="line">CRectangle&amp; ref = r;</span><br><span class="line"><span class="type">int</span> n = ref.nTotalNumber;  <span class="comment">// 这里要注意，nTotalNumber并不是作用在 ref 上的</span></span><br></pre></td></tr></table></figure>


<ul>
<li>静态成员变量本质上是全局变量，即使一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
</ul>
<p>静态成员分为：</p>
<ul>
<li><p>静态成员变量</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li><p>​​​​静态成员函数</p>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p>设置静态成员的机制的目的是将和某些紧密相关的全局变量和函数写到类里，看上去像一个整体，易于维护和理解<br>‍</p>
<p><strong>必须在定义类的文件中，对静态成员变量进行一次说明或初始化，否则编译能通过，链接不能通过</strong></p>
<h2 id="4-3-c-对象模型和-this-指针"><a href="#4-3-c-对象模型和-this-指针" class="headerlink" title="4.3 c++对象模型和 this 指针"></a>4.3 c++对象模型和 this 指针</h2><p>‍</p>
<p>在 C++ 中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mA;  <span class="comment">// 非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB;  <span class="comment">// 静态成员变量不占对象空间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通方法也不占对象空间，所有方法共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>this 指针指向<strong>被调用的成员函数所属的</strong>​<strong>对象</strong></p>
</li>
<li><p>this 指针是隐含每一个<strong>非静态成员函数</strong>内的一种指针</p>
</li>
<li><p>this 指针不需要定义，直接使用即可</p>
</li>
</ul>
<p>‍<br>this 指针的用途：</p>
<ul>
<li>当形参和成员变量（类内的变量）同名时，可用 this 指针来区分</li>
<li>在类的非静态成员函数中返回<strong>对象本身****（类外的对象）</strong>，可使用 return *this</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 1、当形参和成员变量同名时，可用 this 指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;  <span class="comment">// this 指向的是类内非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回对象本身，后续可以进行链式调用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;  <span class="comment">// p1.age = 10</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);  <span class="comment">// 链式调用必须得是对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;  <span class="comment">// p2.age = 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>C++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>
<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	        <span class="comment">// 因为 p 是空指针，没有一个确切的对象，更无法访问它的值了</span></span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;  <span class="comment">// 这里其实有隐藏 buff，mAge 其实是 this-&gt;mAge</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person* p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>();  <span class="comment">// 空指针，可以调用成员函数</span></span><br><span class="line">	<span class="comment">// p-&gt;ShowPerson();  // 但是如果成员函数中用到了 this 指针，就不可以了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-4-友元-friend"><a href="#4-4-友元-friend" class="headerlink" title="4.4 友元 friend"></a>4.4 友元 friend</h2><p>友元分类友元函数和友元类两种</p>
<p>友元：在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问</p>
<p>目的：让一个函数或者类，访问另一个类中私有成员</p>
<p>友元之间的关系不能传递，也不能继承</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<p>只介绍成员函数做友元，其他类似</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	<span class="comment">// 类中声明，类外定义，定义需要使用 :: 运算符</span></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;  <span class="comment">// 只让 visit 函数作为 Building 的好朋友，可以发访问 Building 中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;   <span class="comment">// 不让 vist2 访问私有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 告诉编译器 goodGay 类中的 visit 成员函数是 Building 好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;  <span class="comment">// 注意哦：这里要声明作用域，因为 visit 是全局函数，否则会出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom;  <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;  <span class="comment">// 卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义（这里是为了锻炼，写在类内也可以的）</span></span><br><span class="line"><span class="comment">// a::b -- a 是限定作用域，意思就是 a 的 b</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h2><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h2 id="运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数"><a href="#运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数" class="headerlink" title="运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数"></a>运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数</h2><p>‍</p>
<h3 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h3><p>‍<br>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">// Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载 可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">// 相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>;  <span class="comment">// 相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li><p>对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</li>
<li><p>不要滥用运算符重载</p>
</li>
</ul>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h3><p>作用：可以输出自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现左移重载</span></span><br><span class="line"><span class="comment">// ostream 对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;  <span class="comment">// 链式编程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h3><p>作用： 通过重载递增运算符，实现自己的整型数据递增</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前置++；注意这里的返回值类型必须要有 &amp;，否则多次使 用 ++，不起效果（只有第一次会实现 ++），因为在第一次使用完这个值之后就会释放掉了</span></span><br><span class="line">    	<span class="comment">// 返回引用是为了一直对一个数进行递增</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		m_Num++;  <span class="comment">// 先++</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 再返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后置++；这里其实是前置++函数的重载</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;  <span class="comment">// 注意这里需要有一个占位符，用来区分前置、后置，因为函数返回类型不作为重载的条件</span></span><br><span class="line">		<span class="comment">// 先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>;  <span class="comment">// 记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后 ++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;  <span class="comment">// 后置 ++，一定要返回的是值，因为这里用到了局部变量 temp</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<hr>
<h3 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h3><ul>
<li>赋值运算符，只能重载为成员函数</li>
</ul>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>​默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;，对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">// m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 提供深拷贝，解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1;  <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;  <span class="comment">// 18</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;  <span class="comment">// 18</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;  <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	c = b = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h3><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h3><p>‍</p>
<ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 重载的（）操作符，也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<h2 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h2><p>下级别的成员除了拥有上一级的共性，还有自己的特性。可以利用继承，减少重复代码</p>
<p>继承的语法：<code>class 子类 : 继承方式  父类</code>​​​<br>‍<br>继承方式一共有三种：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>: <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A;  <span class="comment">// 可访问 public 权限</span></span><br><span class="line">		m_B;  <span class="comment">// 可访问 protected 权限</span></span><br><span class="line">		<span class="comment">// m_C;  // 不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A;  <span class="comment">// 其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>: <span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A;  <span class="comment">// 可访问 protected 权限</span></span><br><span class="line">		m_B;  <span class="comment">// 可访问 protected 权限</span></span><br><span class="line">		<span class="comment">// m_C; // 不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">// s.m_A;  // 不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>: <span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A;  <span class="comment">// 父类公共权限可访问，但是变量权限改为 private 权限</span></span><br><span class="line">		m_B;  <span class="comment">// 父类保护权限可访问，但是变量权限改为 private 权限</span></span><br><span class="line">		<span class="comment">//m_C;  // 父类私有权限不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span>: <span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<hr>
<ul>
<li>子类继承父类后，当创建子类对象，也会调用父类的构造函数</li>
<li>先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</li>
</ul>
<p>‍<br>在派生类对象中，包含及基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前</p>
<ul>
<li><p>继承：“是”的关系</p>
<ul>
<li>基类 A，B 是派生类  </li>
<li>逻辑要求：一个 B 对象也是一个 A 对象</li>
</ul>
</li>
<li><p>符合：“有”的关系</p>
<ul>
<li>类 C 中“有”成员变量 k，k 是类 D 的对象，则 C 和 D 是复合关系  </li>
<li>一般逻辑要求：D 对象是 C 对象的固有属性或组成部分</li>
</ul>
</li>
</ul>
<p>‍<br>当子类与父类出现同名的成员：</p>
<ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域，父类名::成员名</li>
</ul>
<p>‍<br>在<strong>创建</strong>派生类的对象时，<br>1）<strong>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员；</strong></p>
<p>2）在执行成员对象类的构造函数，用以初始化派生类对象中成员对象</p>
<p>3）最后执行派生类自己的构造函数</p>
<p>调用基类构造函数的两种方式：</p>
<pre><code>- 显式方式：在派生类的构造函数中，为基类的构造函数提供参数  
- 隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数自动调用基类的默认构造函数
</code></pre>
<p><strong>public 继承</strong>的赋值兼容规则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>: <span class="keyword">public</span> base&#123;&#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d;</span><br></pre></td></tr></table></figure>

<p>1）派生类的对象可以赋值给基类对象（一个派生类对象是一个基类对象）<br>    <code>b = d;  // 把 d 内容拷贝给 b</code>​</p>
<p>2）派生类对象可以初始化基类引用</p>
<p>​	<code>base&amp; br = d;</code>​</p>
<p>3）派生类对象的地址可以赋值给基类指针</p>
<pre><code>base* pb = &amp;d;
</code></pre>
<p>C++ 允许一个类继承多个类</p>
<p>语法<strong>：</strong>​<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code>​​​</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++ 实际开发中不建议用多继承<br>‍</p>
<p><img src="/assets/image-20230527124733-qjm1cxw.png" alt="image"></p>
<p>两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石继承</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承前加 virtual 关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">// 此时公共的父类 Animal 称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="comment">// 直接基类 Tuo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="comment">// 派生类 SheepTuo，可以不用加 virtual</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;  <span class="comment">// 表示将 st.m_Age 赋值为 100，但是呢，m_Age 是在 Sheep 作用域下的</span></span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;  <span class="comment">// 200</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;  <span class="comment">// 200</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;  <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<h2 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h2><p>多态是 C++ 面向对象三大特性之一</p>
<p>多态分为两类</p>
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>‍<br>多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>‍<br>多态使用条件：</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>“多态”的关键在于通过基类指针或引用调用虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 —— “动态联编”</p>
<p>重写：函数返回值类型 、函数名、参数列表完全一致称为重写</p>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>‍<br>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code>​​​</p>
<p><strong>当类中有了纯虚函数，这个类也称为抽象类</strong></p>
<p>‍<br>抽象类特点：</p>
<ul>
<li>无法实例化对象</li>
<li>子类<strong>必须重写</strong>抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 纯虚函数</span></span><br><span class="line">	<span class="comment">// 类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">// 抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">// 子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// base = new Base;  // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;  <span class="comment">// 记得销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>‍</p>
<ul>
<li>在类的定义中，有 virtual 关键字的成员函数就是虚函数</li>
<li>virtual 关键字只用在类定义里的函数声明中，写函数体时不用</li>
<li>构造函数和静态成员函数不能是虚函数</li>
</ul>
<p>看例子理解多态的实现原理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:Print&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:Print&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived);  <span class="comment">// 8, 12</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码可以看出，每个输出都多了 4 个字节，从而引出多态实现的关键 —— 虚函数表</p>
<p>每一个有虚函数的类都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的 4 个字节就是用来放虚函数表的地址的</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/image-20230530155046-huvsjqw.png" alt="image"></h2><p>通过基类指针删除派生类对象时，通常情况下，只能调用基类的析构函数，但是，删除一个派生类对象，应该先调用派生类的析构函数，然后调用基类的析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">son</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from son&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son</span><br><span class="line">&#123;</span><br><span class="line">	~<span class="built_in">grandson</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from grandson&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son* pson;</span><br><span class="line">	pson = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line">	<span class="keyword">delete</span> pson;  <span class="comment">// 输出 bye from son</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：把基类的析构函数声明为 virtual<br>派生类的析构函数可以 virtual 不进行声明<br>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">son</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from son&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son</span><br><span class="line">&#123;</span><br><span class="line">	~<span class="built_in">grandson</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from grandson&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son* pson;</span><br><span class="line">	pson = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line">	<span class="comment">// 先输出 bye from grandson，在输出 bye from son</span></span><br><span class="line">	<span class="keyword">delete</span> pson;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，一个类如果定义了虚函数，应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义为虚函数</p>
<p>注意：不允许以虚函数作为构造函数</p>
<h2 id="‍-1"><a href="#‍-1" class="headerlink" title="‍"></a>‍</h2><p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p>​<code>virtual ~类名()&#123;&#125;</code>​​</p>
<p>纯虚析构语法：</p>
<p>​<code>virtual ~类名() = 0;</code>​</p>
<p>​<code>类名::~类名()&#123;&#125;</code>​​</p>
<ul>
<li>在抽象类的<strong>成员函数内可以调用纯虚函数</strong>，但是在构造函数或析构函数内不能调用纯虚函数</li>
</ul>
<p><strong>总结：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</span><br><span class="line"><span class="number">2.</span> 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</span><br><span class="line"><span class="number">3.</span> 拥有纯虚析构函数的类也属于抽象类</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h1 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过文件可以将数据持久化</p>
<p>C++ 中对文件操作需要包含头文件 <fstream></p>
<p>‍<br>文件类型分为两种：</p>
<ol>
<li>文本文件     -  文件以文本的 <strong>ASCII ​</strong>码形式存储在计算机中</li>
<li>二进制文件 -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>‍<br>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作（往文件输出）</li>
<li>ifstream： 读操作（从文件输入）</li>
<li>fstream ： 读写操作</li>
</ol>
<h2 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h2><p>‍<br><strong>01 写文件</strong>步骤如下：</p>
<ol>
<li>包含头文件<br /><code>#include &lt;fstream&gt;</code>​​</li>
<li>创建流对象<br /><code>ofstream ofs;</code>​​</li>
<li>打开文件<br> ​<code>ofs.open(&quot;文件路径&quot;, 打开方式);</code>​​</li>
<li>写数据<br> ​<code>ofs &lt;&lt; &quot;写入的数据&quot;;</code>​​</li>
<li>关闭文件<br> ​<code>ofs.close();</code>​​<br>‍</li>
</ol>
<p><strong>文件打开方式：</strong></p>
<table>
<thead>
<tr>
<th><strong>打开方式</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ios::in</strong></td>
<td><strong>为读文件而打开文件</strong></td>
</tr>
<tr>
<td><strong>ios::out</strong></td>
<td><strong>为写文件而打开文件</strong></td>
</tr>
<tr>
<td><strong>ios::ate</strong></td>
<td><strong>初始位置：文件尾</strong></td>
</tr>
<tr>
<td><strong>ios::app</strong></td>
<td><strong>追加方式写文件</strong></td>
</tr>
<tr>
<td><strong>ios::trunc</strong></td>
<td><strong>如果文件存在先删除，再创建</strong></td>
</tr>
<tr>
<td><strong>ios::binary</strong></td>
<td><strong>二进制方式</strong></td>
</tr>
</tbody></table>
<p>注意： 文件打开方式可以配合使用，利用 | 操作符</p>
<p>例如：用二进制方式写文件 <code>ios::binary |  ios:: out</code>​​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<p><strong>02 读文件</strong>步骤如下：</p>
<ol>
<li>包含头文件<br> ​<code>#include &lt;fstream&gt;</code>​​</li>
<li>创建流对象<br> ​<code>ifstream ifs;</code>​​</li>
<li>打开文件并判断文件是否打开成功<br> ​<code>ifs.open(&quot;文件路径&quot;, 打开方式);</code>​​</li>
<li>读数据<br> ​<code>四种方式读取</code>​​</li>
<li>关闭文件<br> ​<code>ifs.close();</code>​​</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)  // 按行读取</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf, sizeof(buf)))  // 按行读取</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))  // ifs -- 文件输入流对象，buf -- 文件读取之后存储的地方</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 第四种，不推荐，使用前三种最好</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)  <span class="comment">// get() -- 按字符读取，EOF -- 文件尾部</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<p>03 文件的读写指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;a1.out&quot;</span>, ios::app)</span></span>;  <span class="comment">// 以添加的方式打开</span></span><br><span class="line"><span class="type">long</span> location = fout.<span class="built_in">tellp</span>();  <span class="comment">// 获取写指针的位置</span></span><br><span class="line">location = <span class="number">10</span>;</span><br><span class="line">fout.<span class="built_in">seekp</span>(location);  <span class="comment">// 将写指针移动到第 10 个字节处</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location, ios::beg);  <span class="comment">// 从头数 location</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location, ios::cur);  <span class="comment">// 从当前数 location</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location, ios::end);  <span class="comment">// 从尾部数 location</span></span><br></pre></td></tr></table></figure>
<p>‍</p>
<h2 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h2><p>‍<br>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ios::binary</p>
<p><strong>01 写文件</strong>主要利用流对象调用成员函数 <strong>write</strong></p>
<p>函数原型 ：<code>ostream&amp; write(const char* buffer, long len);</code>​</p>
<p>参数解释：字符指针 buffer 指向内存中一段存储空间，len 是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1、包含头文件</span></span><br><span class="line">	<span class="comment">// 2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">		  </span><br><span class="line">	<span class="comment">// 3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line">	</span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;  <span class="comment">// p 存储在栈中，而&#123;&quot;张三&quot;, 18&#125;存储在堆中</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 4、写文件</span></span><br><span class="line">	<span class="comment">// write(const char* _Str, streamsize_Count)，所以这里要进行强转，这里的_Str是要传地址的！</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp; p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>02 读文件</strong>主要利用流对象调用成员函数 <strong>read</strong></p>
<p>函数原型：<code>istream&amp; read(char *buffer, long len);</code>​</p>
<p>参数解释：字符指针 buffer 指向内存中一段存储空间，len 是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));  <span class="comment">// 这里 read 的第一个参数也是要传地址的！</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

        </article>
        <div class="post-tools" id="post-tools">
            <div class="post-tools-left">
                
                <div class="share-link mobile">
    <div class="share-qrcode">
        <div class="share-button" title="使用手机访问这篇文章">
            <i class="fas fa-qrcode"></i>
        </div>
        <div class="share-main">
            <div class="share-main-all">
                <div id="qrcode" title="http://example.com/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
                </div>
                <div class="reward-dec">使用手机访问这篇文章</div>
            </div>
        </div>
        <script type="text/javascript">
            new QRCode(document.getElementById("qrcode"), "http://example.com/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/");
        </script>
    </div>
</div>
                <div class="share-link weibo"><a class="share-button" target="_blank"
    href="https://service.weibo.com/share/share.php?title=c++ 面向对象&amp;url=http://example.com/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/&amp;pic=/img/cpplogo.jpg"
    title="分享到微博" rel="noopener external nofollow noreferrer noopener">
    <i class="fab fa-weibo" style="font-size:22px"></i>
</a>
</div>
<div class="share-link copyurl">
<div class="share-button" id="post-share-url" title="复制链接" onclick="acrylic.copyPageUrl()">
    <i class="fas fa-link"></i>
</div>
</div>
            </div>
            <div class="post-tools-right">
                <div class="tag_share">
                    <div class="post-meta__tag-list">
                        
                            <a href="/tags/c/" class="post-meta__tags">
                                <span class="tags-punctuation">#</span>
                                c++
                                <span class="tagsPageCount">2</span>
                            </a>
                        
                            <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="post-meta__tags">
                                <span class="tags-punctuation">#</span>
                                编程语言
                                <span class="tagsPageCount">2</span>
                            </a>
                        
                    </div>
                </div>
            </div>
        </div>
        <div class="post-copyright">
    <div class="post-copyright__author">
        <a class="post-copyright__original" title="该文章为原创文章，注意版权协议">原创</a>
        <a class="post-copyright-title" href="#">
            <span>c++ 面向对象</span>
        </a>
    </div>
    <div class="post-copyright__type">
        <span class="post-copyright-info" id="post-copyright-url">
            <a href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">http://example.com/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</a>
        </span>
        <button class="post-copyright-copybtn" onclick="acrylic.copyPageUrl()">
            <i class="fas fa-paste copy-btn"></i>
        </button>
    </div>
    <div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用 <a
                href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a> 协议，完整转载请注明来自 <a
                href="/">Kim&#39;s Blog</a>
            </span>
        </div>
</div>
        <nav class="pagination-post" id="pagination">
    
        
            <div class="next-post pull-full">
                <a href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20-%20%E5%89%AF%E6%9C%AC%20(2)/">
                    <div class="pagination-info">
                        <div class="label">下一篇</div>
                        <div class="next_info">c++ 面向对象</div>
                    </div>
                </a>
            </div>
                
        
    
</nav>
            
    </div>
    <div class="aside-content" id="aside-content">
    
    
        
        <div class="card-widget card-info">
    <div class="card-content">
        <div class="card-info-avatar is-center">
            <div class="author-info__sayhi" id="author-info__sayhi">
            </div>
            <div class="author-info__name">
                Wenjiang Liu
            </div>
            <div class="author-info__description">这有关于<b>生活</b>、<b>科技</b>和<b>深度学习</b>相关的问题和看法<br><br>仅此来记录自己的碎碎念</div>
        </div>
    </div>
    <div class="banner-button-group">
        <a class="banner-button" href="/">
            <i class="fas fa-circle-chevron-right"></i>
            <span class="banner-button-text">个人主页</span>
        </a>
    </div>
    <div class="card-info-social-icons is-center">
        
            <a class="social-icon" target="_blank" rel="noopener" href="https://github.com/freelancelwj7" title="Github">
                <i class="fa-brands fa-github"></i>
            </a>
        
            <a class="social-icon" href="/" title="Mail">
                <i class="fa-solid fa-envelope"></i>
            </a>
        
    </div>
</div>
     
    
    <div class="sticky_layout">
        
            <div class="card-widget" id="card-toc">
    <div class="item-headline">
        <i class="fas fa-bars"></i>
        <span>文章目录</span>
    </div>
    <div class="toc-content" id="toc-content">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-text">1 内存分区模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D"><span class="toc-text">1.1 程序运行前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E"><span class="toc-text">1.2 程序运行后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-new-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">1.3 new 实现动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8"><span class="toc-text">2 引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0"><span class="toc-text">3 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">3.1 普通函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 内联函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">4 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%B0%81%E8%A3%85"><span class="toc-text">4.1 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="toc-text">4.2 对象的初始化和清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">4.2.1 构造函数和析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">4.2.2 深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">4.2.3 初始化列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%8D"><span class="toc-text">‍1234567891011121314151617181920212223242526class Person{public:	&#x2F;&#x2F; 初始化列表方式初始化	Person(int a, int b, int c): m_A(a), m_B(b), m_C(c) {}	void PrintPerson()	{		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;		cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;		cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;	}private:	int m_A;	int m_B;	int m_C;};int main() {	Person p(1, 2, 3);	p.PrintPerson();	return 0;}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">4.2.4 类对象作为类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">4.2.5 静态成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C-this-%E6%8C%87%E9%92%88"><span class="toc-text">4.3 c++对象模型和 this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%8F%8B%E5%85%83-friend"><span class="toc-text">4.4 友元 friend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5 运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9E%E8%B4%A8%E6%98%AF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E4%B8%BA%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5.1 加号运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5.2 左移运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5.3 递增运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5.4 赋值运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-5-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5.5 关系运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-6-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">4.5.6 函数调用运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E7%BB%A7%E6%89%BF"><span class="toc-text">4.6  继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%A4%9A%E6%80%81"><span class="toc-text">4.7  多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%8D-1"><span class="toc-text">‍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">5 文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">5.1文本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">5.2 二进制文件</span></a></li></ol></li></ol>
    </div>
</div>
            
        
            
        <div class="card-widget card-recent-post">
    <div class="item-headline">
        <i class="fas fa-list-ol"></i>
        <span>最近发布</span>
    </div>
    <div class="aside-list">
        
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="c++ 面向对象">
                    <img
                        alt="c++ 面向对象"
                        src="/img/cpplogo.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
                            c++
                        </a>
                    
                    <a class="title" href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="c++ 面向对象">
                        c++ 面向对象
                    </a>
                </div>
            </div>
                
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20-%20%E5%89%AF%E6%9C%AC%20(2)/" title="c++ 面向对象">
                    <img
                        alt="c++ 面向对象"
                        src="/img/cpplogo.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20-%20%E5%89%AF%E6%9C%AC%20(2)/">
                            c++
                        </a>
                    
                    <a class="title" href="/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20-%20%E5%89%AF%E6%9C%AC%20(2)/" title="c++ 面向对象">
                        c++ 面向对象
                    </a>
                </div>
            </div>
                
        
    </div>
</div>
     
        
    </div>
</div> 
</main>
                <footer id="footer">
                    <div id="footer_deal">
    
    <img class="footer_mini_logo" src="/img/avatar.webp"
        title="返回顶部" onclick="acrylic.toTop()">
    
</div>    
<div id="heo-footer">
    
    
</div>
<div id="footer-section">
    <div class="footer-section-links">
        <div class="footer-section-left">
            <div id="footer-section-tips">
                <div class="copyright">©2022 - 2023 By 
                    <a class="footer-section-link" href="/" rel="external nofollow">Wenjiang Liu</a>
                    <a class="footer-section-link" href="https://github.com/hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next" rel="external nofollow" target="_blank"> Theme By Acrylic-Next</a>
                </div>
            </div>
        </div>
        <div class="footer-section-right">
            <a class="footer-section-link" href="/rss/">订阅</a>
            
            <a class="footer-section-link cc" target="_blank" href="https://creativecommons.org/licenses/by/4.0/" title="cc协议">
                <i class="fa-solid fa-closed-captioning"></i>
            </a>
        </div>
    </div>
</div>
                </footer>
            </div>
         
        <div>
    <script type="text/javascript" src="/js/utils.js"></script>
    <script type="text/javascript" src="/js/main.js"></script>
    

<script src="/lib/pjax.min.js"></script>



<script src="/lib/snackbar.min.js"></script>


    
<script src="/lib/view-image.min.js"></script>



<div id="js-pjax">
    
     
</div>

    
<link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css">

    
<script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script>

    
<script src="https://cdn1.tianli0.top/npm/meting@2.0.1/dist/Meting.min.js"></script>

    <script>
        var meting_api = "https://music.startly.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
    </script>


    
<script src="/js/extend/covercolor/web.js"></script>

        


    
<script src="/js/extend/console/console.js"></script>


    <script>
  let pjaxSelectors = [
    'title',
    '#body-wrap',
    '#site-config',
    'meta[name="description"]',
    '#js-pjax'
  ]
  
  const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
  })

  document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
</script>
    
</div>
        
    <div id="local-search">
    <div class="search-dialog">
        <nav class="search-nav">
            <span class="search-dialog-title">搜索</span>
            <button class="search-close-button">
                <i class="fas fa-times"></i>
            </button>
        </nav>
        <div id="loading-database">
            <i class="fas fa-spinner fa-pulse"></i>
            <span>加载中</span>
        </div>
        <div class="search-wrap">
            <div class="search-box">
                <input class="search-box-input" placeholder="Enter keywords to quickly search" type="text" id="search-input" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off">
            </div>
            <div id="loading-status"></div>
            <div id="search-results"></div>
        </div>
    </div>
    <div id="search-mask"></div>
</div>
    
<link rel="stylesheet" href="/css/search/local-search.css">

    
<script src="/js/extend/search/local-search.js"></script>


     
        <div class="needEndHide" id="nav-music" onclick="acrylic.musicToggle()">
    <div id="nav-music-hoverTips">音乐已暂停</div>
    <meting-js id="1708664797" server="tencent" type="playlist" mutex="true"
        preload="none" data-lrctype="0" order="random" theme="var(--heo-main)"></meting-js>
</div>
    
    </body>
</html>
<script>const posts=["2023/06/10/c++面向对象/","2023/06/10/c++面向对象 - 副本 (2)/"];function toRandomPost(){ window.pjax ? pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]) : window.open('/'+posts[Math.floor(Math.random()*posts.length)], "_self"); };</script>