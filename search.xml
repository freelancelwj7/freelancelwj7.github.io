<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++ 面向对象</title>
    <url>/2023/06/10/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h1><p>C++ 程序在执行时，将内存大方向划分为 4 个区域</p>
<ul>
<li>代码区：存放函数体​的二进制代码，由操作系统进行管理</li>
<li>全局区：存放全局变量和静态变量以及常量（字符串常量、const修饰的常量）</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收<span id="more"></span></li>
</ul>
<h2 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h2><p>在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域：</p>
<p><strong>代码区：</strong></p>
<p>存放 CPU 执行的机器指令，代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p><strong>全局区：</strong></p>
<p>该区域的数据在程序结束后由操作系统释放</p>
<h2 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h2><p><strong>栈区：</strong></p>
<p>由编译器自动分配释放，存放函数的参数值，局部变量等<br>‍<br><strong>注意：不要返回局部变量的地址</strong>，栈区开辟的数据由编译器自动释放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆区：</strong></p>
<p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>
<p>主要利用<strong>​ new ​</strong>在堆区开辟内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆区开辟的数据，由程序员手动开辟，手动释放，利用 delete 操作符释放</p>
<p>利用 new 创建的数据，会返回该数据对应的类型的指针</p>
<h2 id="1-3-new-实现动态内存分配"><a href="#1-3-new-实现动态内存分配" class="headerlink" title="1.3 new 实现动态内存分配"></a>1.3 new 实现动态内存分配</h2><ul>
<li><p>第一种用法：分配一个变量 <code>P = new T;</code>​</p>
</li>
<li><p>参数解释：T 是任意类型名，P 是 T* 类型的指针</p>
</li>
<li><p>作用：动态分配一片大小为 sizeof(T) 字节的内存空间，并将该内存空间的起始地址赋值给 P</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* pn;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*pn = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>第二种用法：分配一个数组 <code>P = new T[N];</code>​</li>
<li>参数解释：T 是任意类型名，P 是 T* 类型的指针，N 是要分配的数组元素的个数，可以是整型表达式</li>
<li>作用：动态分配一片大小为 N*sizeof(T) 字节的内存空间，并将该内存空间的起始地址赋值给 P</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* pn;</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="type">int</span>[i * <span class="number">20</span>];</span><br><span class="line">pn[<span class="number">0</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>用 new 动态分配的内存空间，一定要用 delete 释放，否则会一直占用空间，从而可能会导致操作系统或其他应用程序的运行的内存空间都不够</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> 指针;  <span class="comment">// 该指针必须指向 new 出来的空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*p = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">// 不能多次 delete</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] 指针;  <span class="comment">// 该指针必须指向 new 出来的空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>


<h1 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h1><p>作用： 给变量起别名</p>
<p>语法： <code>数据类型&amp; 别名 = 原名</code>​​​</p>
<p>‍</p>
<ul>
<li>指针和引用的补充或者注意事项：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 等价 int* const b = &amp;a;这里也说明了为啥引用一旦初始化之后，就不能再改变了</span></span><br><span class="line"><span class="type">int</span>&amp; b = a; </span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span>;  <span class="comment">// 此时，a 和 b 的值都是 100</span></span><br><span class="line">b = <span class="number">200</span>;  <span class="comment">// 此时，a 和 b 的值都是 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; y = x;  <span class="comment">// 注意这里的 const 修饰的 y，而不是 x ！！！</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">9</span>;  <span class="comment">// 这里仍然可以修改 x 的值，x 和 y 的值都是 9</span></span><br><span class="line"><span class="comment">// y = 99;  // 错误!!因为是 const 修饰的 y</span></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针复习</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ptr = &amp;n;</span><br><span class="line">*ptr = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定 p，既不能修改 p 的指向，也不能修改 p 指向的值，这里说指向的值，是不能用 *p 修改 n 的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;n;</span><br><span class="line">n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// *ptr = 9;  // 错误!!表达式必须是可以修改的左值</span></span><br></pre></td></tr></table></figure>


<p>特点：</p>
<ul>
<li><p>引用必须初始化</p>
</li>
<li><p>引用在初始化后，不可以改变（因为引用的本质其实是伪指针）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rat;</span><br><span class="line"><span class="type">int</span>&amp; rodent = rat;  <span class="comment">// rodent 和 *ptr 是等价的</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;rat;  <span class="comment">// 指针常量，不能改变指针的指向，但是可以改变指向的值</span></span><br></pre></td></tr></table></figure></li>
<li><p>当形参为 const 引用与实参不匹配时，c++ 将生成临时变量，则其行为类似于按值传递，为了确保原始数据不被修改，将使用临时变量存值，以下两种情况会生成临时变量：</p>
<ol>
<li>实参类型正确，但不是左值（可被引用的数据对象，即可通过地址访问的对象）</li>
<li>实参类型不正确，但可以转为正确的类型</li>
</ol>
</li>
<li><p>如果声明将引用指定为 const，c++ 将在必要的时候生成临时变量，但是 const 修饰的引用变量，之后是不可以更改的</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a*a*a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> side = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">long</span> edge = <span class="number">5L</span>;</span><br><span class="line"><span class="type">double</span> lens[<span class="number">4</span>] = &#123;<span class="number">2.0</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">12.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c1 = <span class="built_in">refcube</span>(side);  <span class="comment">// a 是 side</span></span><br><span class="line"><span class="type">double</span> c2 = <span class="built_in">refcube</span>(lens[<span class="number">2</span>]);  <span class="comment">// a 是 lens[2]</span></span><br><span class="line"><span class="type">double</span> c3 = <span class="built_in">refcube</span>(edge);  <span class="comment">// 虽然 c3 的结果是 125，但是 a 是临时变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>现在，如果是普通的引用修饰形参的话，实参与形参类型不匹配，是会报错的，不像之前，会有一个临时变量的转换过程</li>
<li>这里补充一下知识点：非左值包括字面常量（字符串常量除外，他们有自己的地址）和包含多项的表达式</li>
<li>函数传参时，引用可以让形参修饰实参，可以简化指针修改实参</li>
<li>引用必须是要在栈或堆上的变量，不能直接引用常量，如 <code>int&amp; a = 10;</code>​​ 这里说的不能直接引用常量是因为，常量在内存中，是临时地址，随时都能被释放</li>
</ul>
<blockquote>
<p><strong>总结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更简洁</strong></p>
</blockquote>
<hr>
<ul>
<li>引用是可以作为函数的返回值</li>
</ul>
<p>注意：不要返回局部变量引用</p>
<p>用法：函数调用作为左值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;  <span class="comment">// ref = 10</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;  // test01 返回的是局部变量，函数调用完之后，a 的内存被释放了，因此 ref 也被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 20</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 20</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 1000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;  <span class="comment">// ref2 = 1000</span></span><br><span class="line">   </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引用的本质在 c++ 内部实现是一个<strong>指针常量</strong>，但是所有的指针操作编译器都帮我们做了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>;  <span class="comment">// ref 是引用，转换为 *ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>;  <span class="comment">// 内部发现 ref 是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常量引用主要用来修饰形参，防止误操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// v += 10;  // 因为是 const 修饰，所以不能修改 v 的值</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">// 但是如果是 const 修饰的引用，编译器优化代码 int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ref = 100;  // 加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>‍<br>补充：</p>
<ul>
<li>不能把常量指针赋值给非常量指针，反过来可以；不能把常量引用赋值非常量引用，反过来可以</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; x = a;</span><br><span class="line"><span class="comment">// int&amp; y = x;  // 这里会报错，因为将 int&amp; 类型的引用绑定到 const int&amp; 类型的初始值设定时，限定符会被丢弃</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; m = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; n = m;  <span class="comment">// 这里是可以正常编译的</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span>;  <span class="comment">// b m n 的值都是 20</span></span><br><span class="line">m = <span class="number">49</span>;  <span class="comment">// b m n 的值都是 49</span></span><br><span class="line"><span class="comment">// n = 99;  // 错误!!表达式必须是可以修改的左值</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针同上，但是也可以通过强制类型转换的方式，把常量指针赋值给非常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1;</span><br><span class="line"><span class="type">int</span>* p2;</span><br><span class="line"></span><br><span class="line">p1 = p2;  <span class="comment">// ok</span></span><br><span class="line">p2 = p1;  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">p2 = (<span class="type">int</span>*) p1;  <span class="comment">// ok，强制转换</span></span><br></pre></td></tr></table></figure>


<p><strong>常量成员函数补充：</strong></p>
<ul>
<li><p>在类的成员函数声明后面加 const 关键字，则该成员函数是常量成员函数</p>
</li>
<li><p>常量成员函数执行期间，不应该修改其作用的对象（不能修改成员变量的值，静态成员变量除外；也不能调用同类的非常量成员函数 [因为可能会更改]，静态成员函数除外）</p>
</li>
<li><p>两个成员函数，名字和参数一样，但是一个是 const，一个不是，算重载</p>
</li>
</ul>
<hr>
<h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h1><h2 id="3-1-普通函数"><a href="#3-1-普通函数" class="headerlink" title="3.1 普通函数"></a>3.1 普通函数</h2><ul>
<li><p>函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
</li>
<li><p>函数参数可缺省的目的在于提高程序的可扩充性</p>
</li>
</ul>
<p>语法： <code>返回值类型 函数名 (数据类型)&#123;&#125;</code>​​</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);  <span class="comment">// 占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重载作用：函数名可以相同，提高复用性</p>
<p>函数重载满足条件：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名相同</li>
<li>函数参数类型不同或者个数不同或者顺序不同</li>
</ul>
<p>注意:  函数的返回值不可以作为函数重载的条件</p>
<p>函数重载注意事项：</p>
<ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span>  <span class="comment">// int&amp; a = 10; 错误！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int&amp; a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const int&amp; a = 10; 注意这个是合法的！</span></span><br><span class="line"><span class="comment">// 相当于 int tmp = 10; const int&amp; a = tmp;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int&amp; a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数重载碰到函数默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a);  <span class="comment">// 调用无 const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);  <span class="comment">// 调用有 const</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// func2(10);  // 碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-内联函数"><a href="#3-2-内联函数" class="headerlink" title="3.2 内联函数"></a>3.2 内联函数</h2><ul>
<li><p>函数调用是有时间开销的，如果函数本身只有几条语句，执行的非常快。相比之下，调用函数产生的开销就会大很多</p>
</li>
<li><p>为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，时将整个函数的代码插入到调用语句处，而不会产生调用函数的语句</p>
</li>
<li><p>在函数定义前加 inline 关键字，即可定义内联函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h1><p>‍<br>结构化程序设计：程序 &#x3D; 数据结构 + 算法</p>
<p>面向对象的程序 &#x3D; 类 + 类 + … + 类</p>
<p>设计程序的过程，就是设计类的过程！</p>
<p>‍</p>
<p>面向对象的程序设计方法：</p>
<ul>
<li><p>将某类客观事物共同特点（属性）归纳出来，形成一个数据结构</p>
</li>
<li><p>将这类事物能进行的行为也归纳出来，形成一个函数，这些函数可以用来操作数据结构（这一步叫“抽象”）</p>
</li>
<li><p>类的成员函数和类的定义分开写（类外的定义需要使用 :: 运算符限定作用域）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> w, h;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Area</span><span class="params">()</span></span>;  <span class="comment">// 声明成员函数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Perimeter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> w_, <span class="type">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRectangle::Area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRectangle::Perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * (w + h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::Init</span><span class="params">(<span class="type">int</span> w_, <span class="type">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	w = w_; h = h_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>C++ 面向对象的三大特性为：<strong>封装、继承、多态</strong></p>
<p>C++ 认为万事万物皆对象，对象上有属性和行为</p>
<h2 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h2><p>‍</p>
<ul>
<li><p>类中的变量称为成员变量，类中的函数称为成员函数，类定义出来的变量，也称为类的实例，也是“对象”</p>
</li>
<li><p>每个对象各有自己的存储空间，一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个类，从而使得数据结构和操作该数据结构的算法呈现出紧密关系，这就是“封装”</p>
</li>
</ul>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现为事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p>访问权限有三种：</p>
<ol>
<li>public         公共权限    类内可以访问  类外可以访问</li>
<li>protected   保护权限    类内可以访问  类外不可以访问</li>
<li>private        私有权限    类内可以访问  类外不可以访问</li>
</ol>
<p>设置私有成员的机制，叫“隐藏”，隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，以后需要对成员变量的类型等属性修改后，只修改成员函数即可。否则，所有直接访问成员变量的语句都需要修改</p>
<p>在类的成员函数内部，能访问：</p>
<ul>
<li>当前对象的全部属性、函数</li>
<li>同类其他对象的全部属性、函数</li>
</ul>
<p>在类的成员函数以外的地方，只能访问该类对象的公有成员</p>
<p>在 C++ 中 struct 和 class 唯一的区别就在于默认的访问权限不同</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<h2 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h2><p>C++ 中的面向对象来源于生活，每个对象都有初始设置以及对象销毁前的清理数据</p>
<hr>
<h3 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h3><p>对象的初始化和清理是两个非常重要的安全问题</p>
<p>c++ 利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>
<p>编译器提供的构造函数和析构函数是空实现</p>
<ul>
<li>构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</li>
<li>析构函数：在对象销毁前系统自动调用，执行一些清理工作</li>
</ul>
<p>构造函数语法：<code>类名()&#123;&#125;</code>​​</p>
<ol>
<li>构造函数，没有返回值也不写 void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造函数，无须手动调用，而且只会调用一次</li>
</ol>
<p>析构函数语法： <code>~类名()&#123;&#125;</code>​​</p>
<ol>
<li>析构函数，没有返回值也不写 void</li>
<li>函数名称与类名相同，在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li>
</ol>
<p>析构函数的两种分类方式：</p>
<ul>
<li>按参数分为： 有参构造和无参构造（默认）</li>
<li>按类型分为： 普通构造和拷贝构造</li>
</ul>
<p>析构函数的三种调用方式：</p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐式转换法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、构造函数分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;  <span class="comment">// 限定拷贝的时候，不能更改实参</span></span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、构造函数的调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;  <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.1 括号法（常用）</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Person p2();  // 注意1：调用无参构造函数不能加括号，否则编译器认为这是函数声明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">// Person(10);  // 单独写就是匿名对象，当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意2：这里不要利用拷贝构造函数初始化匿名对象，编译器会认为是对象声明</span></span><br><span class="line">	<span class="comment">// Person(p9);  // Person(p9) == Person p9;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>;  <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4;  <span class="comment">// Person p5 = Person(p4);  // 拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Person p5(p4);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>C++ 中拷贝构造函数调用时机通常有三种情况：</p>
<ul>
<li>用一个对象去初始化同类的另一个对象</li>
<li>如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的拷贝构造函数将被调用</li>
<li>如果函数的返回值是类 A 的对象，则函数返回时，A 的拷贝改造函数被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// p 对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man;  <span class="comment">// 拷贝构造</span></span><br><span class="line">	<span class="comment">// 隐式转换法</span></span><br><span class="line">	<span class="comment">// Person newman3 = man;  // 不是调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">// 相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;  <span class="comment">// 无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;  <span class="comment">// 局部对象在 doWork2() 作用完后，随即被释放</span></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)&amp;p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意这里返回 p1 是可以的，因为他在这里创建了一个副本，这个副本指的是拷贝构造函数产生的对象，生命周期要看它被使用到什么时候！只有返回引用和指针类型的数据才会报错</span></span><br><span class="line">	<span class="keyword">return</span> p1;  <span class="comment">// 这里返回的不是 p1 本身，而是创建一个 p1 副本返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，编译器至少给一个类添加 3 个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则：</p>
<ul>
<li>如果用户定义有参构造函数，c++ 不再提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，c++ 不再提供其他构造函数<br>‍</li>
</ul>
<p>注意：构造函数知识点补充</p>
<ol>
<li>如果自定义了有参构造函数，那么就不能再使用无参构造函数定义变量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	real = r, imag = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Complex c1;  <span class="comment">// error，缺少构造函数的参数</span></span><br><span class="line">	Complex* pc = <span class="keyword">new</span> Complex;  <span class="comment">// error，缺少构造函数的参数</span></span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>;  <span class="comment">// OK</span></span><br><span class="line">	Complex* pc = <span class="keyword">new</span> Complex;  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造函数在数组中的使用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSample</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSample</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor 1 Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CSample</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		x = n;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor 2 Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSample array[<span class="number">2</span>];  <span class="comment">// 输出两次 Constructor 1 Called</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	CSample array2[<span class="number">2</span>] = &#123; <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;  <span class="comment">// 输出两次 Constructor 2 Called</span></span><br><span class="line"></span><br><span class="line">	CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;  <span class="comment">// Constructor 2 Called，Constructor 1 Called</span></span><br><span class="line"></span><br><span class="line">	CSample* array4 = <span class="keyword">new</span> CSample[<span class="number">2</span>];  <span class="comment">// 输出两次 Constructor 1 Called</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] array4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>补充：</strong></p>
<p><strong>01 拷贝构造函数：</strong></p>
<ul>
<li>只有一个参数，即对同类对象的引用</li>
<li>形如 X::X( X&amp; )或 X::X( const X&amp; )，二者选一，注意参数必须是引用！后者能以常量对象作为参数</li>
<li>如果没有定义拷贝构造函数，那么编译器生成默认复制构造函数，默认的拷贝构造函数完成复制功能</li>
</ul>
<p>注意：</p>
<ul>
<li>对象间赋值并不导致拷贝构造函数被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">CMyclass</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">CMyclass</span>(CMyclass&amp; c) &#123;</span><br><span class="line">		n = <span class="number">2</span> * c.n;  <span class="comment">// 拷贝构造函数一般不这么做，这里只是为了举例子</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CMyclass c1, c2;</span><br><span class="line">	c1.n = <span class="number">5</span>;</span><br><span class="line">	c2 = c1;  <span class="comment">// 赋值语句，不是初始化语句，因此这里不会调用拷贝构造函数</span></span><br><span class="line">	<span class="function">CMyclass <span class="title">c3</span><span class="params">(c1)</span></span>;  <span class="comment">// 会调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c2.n=&quot;</span> &lt;&lt; c2.n &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">// 5</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c3.n=&quot;</span> &lt;&lt; c3.n &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍<br><strong>02 常量引用参数的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(CMyclass obj_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的函数，调用时生成形参会引发拷贝构造函数调用，开销大。因此，考虑使用 CMyclass&amp; 引用类型作为参数</li>
<li>如果希望实参的值在函数中不被改变，可以加上 const 关键字</li>
</ul>
<p><strong>03 类型转换构造函数</strong></p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换</li>
<li>只有一个参数，而且不是拷贝构造函数的构造函数，一般就可以看作是转换构造函数</li>
<li>当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> real, imag;</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> i)  <span class="comment">// 类型转换构造函数，如果碰到类型不匹配的，那么会生成临时变量来接收</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;IntConstructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">		real = i;</span><br><span class="line">		imag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) &#123; real = r; imag = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">	Complex c2 = <span class="number">12</span>;</span><br><span class="line">	<span class="comment">// 因为这里直接赋值的话，类型是不匹配的。9 被自动转为临时 Complex 对象</span></span><br><span class="line">	c1 = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c1.real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; c1.imag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>04 析构函数和数组</strong></p>
<ul>
<li>对象数组声明周期结束时，对象数组的每个元素的析构函数都会被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ctest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Ctest</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ctest array[<span class="number">2</span>];  <span class="comment">// 输出两次 destructor called</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;End main&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<p><strong>05 析构函数和运算符 delete</strong></p>
<ul>
<li>delete 运算导致析构函数调用</li>
<li>如果 new 一个对象数组，用 delete 释放时应该写 []，否则只 delete 一个对象（调用一次析构函数）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Ctest* pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest;  <span class="comment">// 构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;  <span class="comment">// 析构函数调用</span></span><br><span class="line">------------------------------------------</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>];  <span class="comment">// 调用 3 次构造函数</span></span><br><span class="line"><span class="keyword">delete</span>[] pTest;  <span class="comment">// 调用 3 次析构函数</span></span><br></pre></td></tr></table></figure>


<p><strong>06 析构函数在对象作为函数返回值后被调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyclass obj;  <span class="comment">// 全局函数变量，整个程序结束时，也会调用析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的形参被传入参数时，调用 CMyclass 的构造函数，当参数对象消亡，也会调用析构函数</span></span><br><span class="line"><span class="function">CMyclass <span class="title">fun</span><span class="params">(CMyclass sobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里注意 2 个点</span></span><br><span class="line">	<span class="comment">// 1.这里生成返回的临时对象</span></span><br><span class="line">	<span class="keyword">return</span> sobj;  <span class="comment">// 函数调用返回时，返回的是生成的临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 函数调用的返回值（临时对象）被用过后，该临时对象析构函数被调用</span></span><br><span class="line">	<span class="comment">// 这里是用临时对象给 obj 赋值</span></span><br><span class="line">	<span class="comment">// 2.临时对象的生命周期在执行完下行语句后消亡</span></span><br><span class="line">	obj = <span class="built_in">fun</span>(obj);  <span class="comment">// 输出 3 次 destructor</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>07 构造函数和析构函数的调用时机</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CMyclass</span>(<span class="type">int</span> i)  <span class="comment">// 类型转换构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		id = i;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;id = &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;id = &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; destructed&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CMyclass <span class="title">d1</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">// 因为这里有全局变量，所以 d1 调用构造函数比 main 中的还早</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">static</span> CMyclass <span class="title">d2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">CMyclass <span class="title">d3</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 程序执行输出结果</span></span><br><span class="line"><span class="comment">	id = 1 constructed</span></span><br><span class="line"><span class="comment">	id = 4 constructed</span></span><br><span class="line"><span class="comment">	id = 6 constructed</span></span><br><span class="line"><span class="comment">	id = 6 destructed</span></span><br><span class="line"><span class="comment">	main</span></span><br><span class="line"><span class="comment">	id = 5 constructed</span></span><br><span class="line"><span class="comment">	id = 5 destructed</span></span><br><span class="line"><span class="comment">	id = 2 constructed</span></span><br><span class="line"><span class="comment">	id = 3 constructed</span></span><br><span class="line"><span class="comment">	func</span></span><br><span class="line"><span class="comment">	id = 3 destructed</span></span><br><span class="line"><span class="comment">	main ends！</span></span><br><span class="line"><span class="comment">	id = 6 destructed</span></span><br><span class="line"><span class="comment">	id = 2 destructed</span></span><br><span class="line"><span class="comment">	id = 1 destructed</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function">CMyclass <span class="title">d4</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	d4 = <span class="number">6</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;<span class="function">CMyclass <span class="title">d5</span><span class="params">(<span class="number">5</span>)</span></span>; &#125;  <span class="comment">// 局部变量，遇到有大括号后，变量使用结束</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main ends！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-2-2-深拷贝与浅拷贝"><a href="#4-2-2-深拷贝与浅拷贝" class="headerlink" title="4.2.2 深拷贝与浅拷贝"></a>4.2.2 深拷贝与浅拷贝</h3><p>浅拷贝：引用做函数返回值，会带来堆区的内存重复释放（一般是在调用构造函数有时产生的问题）</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义拷贝构造函数，解决浅拷贝带来的问题</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person 拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		<span class="comment">// m_Height = p.m_height;  // 编译器默认写的浅拷贝</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);  <span class="comment">// 这里要加括号，是固定用法，记住就行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">			m_height = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;  <span class="comment">// 指针变量存放在栈，指针指向的值存放在堆中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;  <span class="comment">// 因为 m_height 是指针变量，所以，*m_height 的值被存放在堆中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为 p1 和 p2 是在栈中存储的，所以存储的时候，是先存储 p1 再存储 p2</span></span><br><span class="line">	<span class="comment">// 因此在释放（调用析构函数）的时候，先释放 p2 再释放 p1</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">// 拷贝构造函数，是浅拷贝。所以，p1 和 p2 的 m_height 指向的是同一块内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：这里用指针，是为了更好地突出深拷贝和浅拷贝面临的问题</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-2-3-初始化列表"><a href="#4-2-3-初始化列表" class="headerlink" title="4.2.3 初始化列表"></a>4.2.3 初始化列表</h3><p>作用：用来初始化属性</p>
<p>语法：<code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code>​​​</p>
<p>‍<br>成员对象和封闭类：有成员对象的类叫封闭（enclosing）类</p>
<p>‍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c): <span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-2-4-类对象作为类成员"><a href="#4-2-4-类对象作为类成员" class="headerlink" title="4.2.4 类对象作为类成员"></a>4.2.4 类对象作为类成员</h3><p>对象成员：类中的成员是另一个类的对象。B 类中有对象 A 作为成员，A 为对象成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建 B 对象时，构造的顺序是：先调用对象成员（A）的构造函数，再调用本类构造；析构顺序相反</p>
<p>封闭类的复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(A &amp;a) &#123; cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; A a; &#125;;  <span class="comment">// 既有无参构造函数，也有拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*输出</span></span><br><span class="line"><span class="comment">	default</span></span><br><span class="line"><span class="comment">	copy*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 说明 b2.a 是用类 A 的拷贝构造函数初始化的。而且调用拷贝构造函数时的实参就是 b1.a</span></span><br><span class="line">	B b1;  <span class="comment">// 这里输出的是 default</span></span><br><span class="line">	<span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;  <span class="comment">// 此时，拷贝构造函数不是简单地把 b1 拷贝给 b2，是用类 A 的拷贝构造函数初始化的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-2-5-静态成员"><a href="#4-2-5-静态成员" class="headerlink" title="4.2.5 静态成员"></a>4.2.5 静态成员</h3><ul>
<li><p>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>
</li>
<li><p>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享</p>
</li>
<li><p>sizeof 不会计算静态成员变量</p>
</li>
<li><p>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象；因此，静态成员不需要通过对象就能访问<br>‍</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.类名::成员名</span></span><br><span class="line">CRectangle::<span class="built_in">PrintTotal</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对象名.成员名</span></span><br><span class="line">CRectangle r;</span><br><span class="line">r.<span class="built_in">PrintTotal</span>();  <span class="comment">// 这里要注意，PrintTotal 并不是作用在 r 上的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.指针-&gt;成员名</span></span><br><span class="line">CRectangle* p = &amp;r;</span><br><span class="line">p-&gt;<span class="built_in">PrintTotal</span>();  <span class="comment">// 这里要注意，PrintTotal 并不是作用在 p 上的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.引用.成员名</span></span><br><span class="line">CRectangle&amp; ref = r;</span><br><span class="line"><span class="type">int</span> n = ref.nTotalNumber;  <span class="comment">// 这里要注意，nTotalNumber并不是作用在 ref 上的</span></span><br></pre></td></tr></table></figure>


<ul>
<li>静态成员变量本质上是全局变量，即使一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
</ul>
<p>静态成员分为：</p>
<ul>
<li><p>静态成员变量</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li><p>​​​​静态成员函数</p>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p>设置静态成员的机制的目的是将和某些紧密相关的全局变量和函数写到类里，看上去像一个整体，易于维护和理解<br>‍</p>
<p><strong>必须在定义类的文件中，对静态成员变量进行一次说明或初始化，否则编译能通过，链接不能通过</strong></p>
<h2 id="4-3-c-对象模型和-this-指针"><a href="#4-3-c-对象模型和-this-指针" class="headerlink" title="4.3 c++对象模型和 this 指针"></a>4.3 c++对象模型和 this 指针</h2><p>‍</p>
<p>在 C++ 中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mA;  <span class="comment">// 非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB;  <span class="comment">// 静态成员变量不占对象空间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通方法也不占对象空间，所有方法共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>this 指针指向<strong>被调用的成员函数所属的</strong>​<strong>对象</strong></p>
</li>
<li><p>this 指针是隐含每一个<strong>非静态成员函数</strong>内的一种指针</p>
</li>
<li><p>this 指针不需要定义，直接使用即可</p>
</li>
</ul>
<p>‍<br>this 指针的用途：</p>
<ul>
<li>当形参和成员变量（类内的变量）同名时，可用 this 指针来区分</li>
<li>在类的非静态成员函数中返回<strong>对象本身****（类外的对象）</strong>，可使用 return *this</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 1、当形参和成员变量同名时，可用 this 指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;  <span class="comment">// this 指向的是类内非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回对象本身，后续可以进行链式调用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;  <span class="comment">// p1.age = 10</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);  <span class="comment">// 链式调用必须得是对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;  <span class="comment">// p2.age = 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>C++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>
<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	        <span class="comment">// 因为 p 是空指针，没有一个确切的对象，更无法访问它的值了</span></span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;  <span class="comment">// 这里其实有隐藏 buff，mAge 其实是 this-&gt;mAge</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person* p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>();  <span class="comment">// 空指针，可以调用成员函数</span></span><br><span class="line">	<span class="comment">// p-&gt;ShowPerson();  // 但是如果成员函数中用到了 this 指针，就不可以了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-4-友元-friend"><a href="#4-4-友元-friend" class="headerlink" title="4.4 友元 friend"></a>4.4 友元 friend</h2><p>友元分类友元函数和友元类两种</p>
<p>友元：在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问</p>
<p>目的：让一个函数或者类，访问另一个类中私有成员</p>
<p>友元之间的关系不能传递，也不能继承</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<p>只介绍成员函数做友元，其他类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	<span class="comment">// 类中声明，类外定义，定义需要使用 :: 运算符</span></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;  <span class="comment">// 只让 visit 函数作为 Building 的好朋友，可以发访问 Building 中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;   <span class="comment">// 不让 vist2 访问私有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 告诉编译器 goodGay 类中的 visit 成员函数是 Building 好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;  <span class="comment">// 注意哦：这里要声明作用域，因为 visit 是全局函数，否则会出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom;  <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;  <span class="comment">// 卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义（这里是为了锻炼，写在类内也可以的）</span></span><br><span class="line"><span class="comment">// a::b -- a 是限定作用域，意思就是 a 的 b</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h2><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<p>运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数<br>‍</p>
<h3 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h3><p>‍<br>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">// Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载 可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">// 相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>;  <span class="comment">// 相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li><p>对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</li>
<li><p>不要滥用运算符重载</p>
</li>
</ul>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h3><p>作用：可以输出自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现左移重载</span></span><br><span class="line"><span class="comment">// ostream 对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;  <span class="comment">// 链式编程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h3><p>作用： 通过重载递增运算符，实现自己的整型数据递增</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前置++；注意这里的返回值类型必须要有 &amp;，否则多次使 用 ++，不起效果（只有第一次会实现 ++），因为在第一次使用完这个值之后就会释放掉了</span></span><br><span class="line">    	<span class="comment">// 返回引用是为了一直对一个数进行递增</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		m_Num++;  <span class="comment">// 先++</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 再返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后置++；这里其实是前置++函数的重载</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;  <span class="comment">// 注意这里需要有一个占位符，用来区分前置、后置，因为函数返回类型不作为重载的条件</span></span><br><span class="line">		<span class="comment">// 先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>;  <span class="comment">// 记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后 ++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;  <span class="comment">// 后置 ++，一定要返回的是值，因为这里用到了局部变量 temp</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<hr>
<h3 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h3><ul>
<li>赋值运算符，只能重载为成员函数</li>
</ul>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>​默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;，对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">// m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 提供深拷贝，解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1;  <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;  <span class="comment">// 18</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;  <span class="comment">// 18</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;  <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	c = b = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h3><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h3><p>‍</p>
<ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 重载的（）操作符，也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<h2 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h2><p>下级别的成员除了拥有上一级的共性，还有自己的特性。可以利用继承，减少重复代码</p>
<p>继承的语法：<code>class 子类 : 继承方式  父类</code>​​​<br>‍<br>继承方式一共有三种：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>: <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A;  <span class="comment">// 可访问 public 权限</span></span><br><span class="line">		m_B;  <span class="comment">// 可访问 protected 权限</span></span><br><span class="line">		<span class="comment">// m_C;  // 不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A;  <span class="comment">// 其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>: <span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A;  <span class="comment">// 可访问 protected 权限</span></span><br><span class="line">		m_B;  <span class="comment">// 可访问 protected 权限</span></span><br><span class="line">		<span class="comment">// m_C; // 不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">// s.m_A;  // 不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>: <span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A;  <span class="comment">// 父类公共权限可访问，但是变量权限改为 private 权限</span></span><br><span class="line">		m_B;  <span class="comment">// 父类保护权限可访问，但是变量权限改为 private 权限</span></span><br><span class="line">		<span class="comment">//m_C;  // 父类私有权限不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span>: <span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<hr>
<ul>
<li>子类继承父类后，当创建子类对象，也会调用父类的构造函数</li>
<li>先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</li>
</ul>
<p>‍<br>在派生类对象中，包含及基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前</p>
<ul>
<li><p>继承：“是”的关系</p>
<ul>
<li>基类 A，B 是派生类  </li>
<li>逻辑要求：一个 B 对象也是一个 A 对象</li>
</ul>
</li>
<li><p>符合：“有”的关系</p>
<ul>
<li>类 C 中“有”成员变量 k，k 是类 D 的对象，则 C 和 D 是复合关系  </li>
<li>一般逻辑要求：D 对象是 C 对象的固有属性或组成部分</li>
</ul>
</li>
</ul>
<p>‍<br>当子类与父类出现同名的成员：</p>
<ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域，父类名::成员名</li>
</ul>
<p>‍<br>在<strong>创建</strong>派生类的对象时，<br>1）<strong>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员；</strong></p>
<p>2）在执行成员对象类的构造函数，用以初始化派生类对象中成员对象</p>
<p>3）最后执行派生类自己的构造函数</p>
<p>调用基类构造函数的两种方式：</p>
<pre><code>- 显式方式：在派生类的构造函数中，为基类的构造函数提供参数  
- 隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数自动调用基类的默认构造函数
</code></pre>
<p><strong>public 继承</strong>的赋值兼容规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>: <span class="keyword">public</span> base&#123;&#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d;</span><br></pre></td></tr></table></figure>

<p>1）派生类的对象可以赋值给基类对象（一个派生类对象是一个基类对象）<br>    <code>b = d;  // 把 d 内容拷贝给 b</code>​</p>
<p>2）派生类对象可以初始化基类引用</p>
<p>​	<code>base&amp; br = d;</code>​</p>
<p>3）派生类对象的地址可以赋值给基类指针</p>
<pre><code>base* pb = &amp;d;
</code></pre>
<p>C++ 允许一个类继承多个类</p>
<p>语法<strong>：</strong>​<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code>​​​</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++ 实际开发中不建议用多继承<br>‍</p>
<p><img src="/assets/image-20230527124733-qjm1cxw.png" alt="image"></p>
<p>两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石继承</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承前加 virtual 关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">// 此时公共的父类 Animal 称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="comment">// 直接基类 Tuo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="comment">// 派生类 SheepTuo，可以不用加 virtual</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;  <span class="comment">// 表示将 st.m_Age 赋值为 100，但是呢，m_Age 是在 Sheep 作用域下的</span></span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;  <span class="comment">// 200</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;  <span class="comment">// 200</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;  <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<h2 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h2><p>多态是 C++ 面向对象三大特性之一</p>
<p>多态分为两类</p>
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>‍<br>多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>‍<br>多态使用条件：</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>“多态”的关键在于通过基类指针或引用调用虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 —— “动态联编”</p>
<p>重写：函数返回值类型 、函数名、参数列表完全一致称为重写</p>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>‍<br>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code>​​​</p>
<p><strong>当类中有了纯虚函数，这个类也称为抽象类</strong></p>
<p>‍<br>抽象类特点：</p>
<ul>
<li>无法实例化对象</li>
<li>子类<strong>必须重写</strong>抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 纯虚函数</span></span><br><span class="line">	<span class="comment">// 类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">// 抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">// 子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// base = new Base;  // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;  <span class="comment">// 记得销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>‍</p>
<ul>
<li>在类的定义中，有 virtual 关键字的成员函数就是虚函数</li>
<li>virtual 关键字只用在类定义里的函数声明中，写函数体时不用</li>
<li>构造函数和静态成员函数不能是虚函数</li>
</ul>
<p>看例子理解多态的实现原理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:Print&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:Print&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived);  <span class="comment">// 8, 12</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码可以看出，每个输出都多了 4 个字节，从而引出多态实现的关键 —— 虚函数表</p>
<p>每一个有虚函数的类都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的 4 个字节就是用来放虚函数表的地址的</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/image-20230530155046-huvsjqw.png" alt="image"></h2><p>通过基类指针删除派生类对象时，通常情况下，只能调用基类的析构函数，但是，删除一个派生类对象，应该先调用派生类的析构函数，然后调用基类的析构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">son</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from son&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son</span><br><span class="line">&#123;</span><br><span class="line">	~<span class="built_in">grandson</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from grandson&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son* pson;</span><br><span class="line">	pson = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line">	<span class="keyword">delete</span> pson;  <span class="comment">// 输出 bye from son</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：把基类的析构函数声明为 virtual<br>派生类的析构函数可以 virtual 不进行声明<br>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">son</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from son&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son</span><br><span class="line">&#123;</span><br><span class="line">	~<span class="built_in">grandson</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from grandson&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son* pson;</span><br><span class="line">	pson = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line">	<span class="comment">// 先输出 bye from grandson，在输出 bye from son</span></span><br><span class="line">	<span class="keyword">delete</span> pson;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，一个类如果定义了虚函数，应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义为虚函数</p>
<p>注意：不允许以虚函数作为构造函数</p>
<h2 id="‍"><a href="#‍" class="headerlink" title="‍"></a>‍</h2><p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p>​<code>virtual ~类名()&#123;&#125;</code>​​</p>
<p>纯虚析构语法：</p>
<p>​<code>virtual ~类名() = 0;</code>​</p>
<p>​<code>类名::~类名()&#123;&#125;</code>​​</p>
<ul>
<li>在抽象类的<strong>成员函数内可以调用纯虚函数</strong>，但是在构造函数或析构函数内不能调用纯虚函数</li>
</ul>
<p><strong>总结：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</span><br><span class="line"><span class="number">2.</span> 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</span><br><span class="line"><span class="number">3.</span> 拥有纯虚析构函数的类也属于抽象类</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h1 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过文件可以将数据持久化</p>
<p>C++ 中对文件操作需要包含头文件 <fstream></p>
<p>‍<br>文件类型分为两种：</p>
<ol>
<li>文本文件     -  文件以文本的 <strong>ASCII ​</strong>码形式存储在计算机中</li>
<li>二进制文件 -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>‍<br>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作（往文件输出）</li>
<li>ifstream： 读操作（从文件输入）</li>
<li>fstream ： 读写操作</li>
</ol>
<h2 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h2><p>‍<br><strong>01 写文件</strong>步骤如下：</p>
<ol>
<li>包含头文件<br /><code>#include &lt;fstream&gt;</code>​​</li>
<li>创建流对象<br /><code>ofstream ofs;</code>​​</li>
<li>打开文件<br> ​<code>ofs.open(&quot;文件路径&quot;, 打开方式);</code>​​</li>
<li>写数据<br> ​<code>ofs &lt;&lt; &quot;写入的数据&quot;;</code>​​</li>
<li>关闭文件<br> ​<code>ofs.close();</code>​​<br>‍</li>
</ol>
<p><strong>文件打开方式：</strong></p>
<table>
<thead>
<tr>
<th><strong>打开方式</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ios::in</strong></td>
<td><strong>为读文件而打开文件</strong></td>
</tr>
<tr>
<td><strong>ios::out</strong></td>
<td><strong>为写文件而打开文件</strong></td>
</tr>
<tr>
<td><strong>ios::ate</strong></td>
<td><strong>初始位置：文件尾</strong></td>
</tr>
<tr>
<td><strong>ios::app</strong></td>
<td><strong>追加方式写文件</strong></td>
</tr>
<tr>
<td><strong>ios::trunc</strong></td>
<td><strong>如果文件存在先删除，再创建</strong></td>
</tr>
<tr>
<td><strong>ios::binary</strong></td>
<td><strong>二进制方式</strong></td>
</tr>
</tbody></table>
<p>注意： 文件打开方式可以配合使用，利用 | 操作符</p>
<p>例如：用二进制方式写文件 <code>ios::binary |  ios:: out</code>​​</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<p><strong>02 读文件</strong>步骤如下：</p>
<ol>
<li>包含头文件<br> ​<code>#include &lt;fstream&gt;</code>​​</li>
<li>创建流对象<br> ​<code>ifstream ifs;</code>​​</li>
<li>打开文件并判断文件是否打开成功<br> ​<code>ifs.open(&quot;文件路径&quot;, 打开方式);</code>​​</li>
<li>读数据<br> ​<code>四种方式读取</code>​​</li>
<li>关闭文件<br> ​<code>ifs.close();</code>​​</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)  // 按行读取</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf, sizeof(buf)))  // 按行读取</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))  // ifs -- 文件输入流对象，buf -- 文件读取之后存储的地方</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 第四种，不推荐，使用前三种最好</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)  <span class="comment">// get() -- 按字符读取，EOF -- 文件尾部</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‍</p>
<p>03 文件的读写指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;a1.out&quot;</span>, ios::app)</span></span>;  <span class="comment">// 以添加的方式打开</span></span><br><span class="line"><span class="type">long</span> location = fout.<span class="built_in">tellp</span>();  <span class="comment">// 获取写指针的位置</span></span><br><span class="line">location = <span class="number">10</span>;</span><br><span class="line">fout.<span class="built_in">seekp</span>(location);  <span class="comment">// 将写指针移动到第 10 个字节处</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location, ios::beg);  <span class="comment">// 从头数 location</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location, ios::cur);  <span class="comment">// 从当前数 location</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location, ios::end);  <span class="comment">// 从尾部数 location</span></span><br></pre></td></tr></table></figure>
<p>‍</p>
<h2 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h2><p>‍<br>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ios::binary</p>
<p><strong>01 写文件</strong>主要利用流对象调用成员函数 <strong>write</strong></p>
<p>函数原型 ：<code>ostream&amp; write(const char* buffer, long len);</code>​</p>
<p>参数解释：字符指针 buffer 指向内存中一段存储空间，len 是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1、包含头文件</span></span><br><span class="line">	<span class="comment">// 2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">		  </span><br><span class="line">	<span class="comment">// 3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line">	</span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;  <span class="comment">// p 存储在栈中，而&#123;&quot;张三&quot;, 18&#125;存储在堆中</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 4、写文件</span></span><br><span class="line">	<span class="comment">// write(const char* _Str, streamsize_Count)，所以这里要进行强转，这里的_Str是要传地址的！</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp; p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>02 读文件</strong>主要利用流对象调用成员函数 <strong>read</strong></p>
<p>函数原型：<code>istream&amp; read(char *buffer, long len);</code>​</p>
<p>参数解释：字符指针 buffer 指向内存中一段存储空间，len 是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));  <span class="comment">// 这里 read 的第一个参数也是要传地址的！</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>技术归纳</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 泛型编程</title>
    <url>/2023/06/10/c++%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1 函数模板"></a>1 函数模板</h1><p>模板就是建立通用的模具，大大提高复用性</p>
<ul>
<li>​C++ 另一种编程思想称为&#x3D;&#x3D;泛型编程&#x3D;&#x3D;，主要利用的技术就是模板</li>
<li>​C++ 提供两种模板机制：函数模板和类模板‍</li>
</ul>
<p>模板的特点：</p>
<ul>
<li>​​模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h2 id="1-1-函数模板"><a href="#1-1-函数模板" class="headerlink" title="1.1 函数模板"></a>1.1 函数模板</h2><ul>
<li>C++ 提供两种模板机制：函数模板和类模板</li>
</ul>
<p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 函数声明或定义</span><br></pre></td></tr></table></figure>

<p>​​template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用 class 代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p>‍</p>
<p>模板就是让编译器自动生成一大堆函数，由模板生成函数的过程，被称为模板的实例化</p>
<p>‍</p>
<ul>
<li>我们在交换两个变量的值时，因为他们的类型不一样需要写两个交换函数，但是这两个函数只有变量的类型不一致，其他方面全部一致，因此可以使用模板的概念简化代码</li>
<li>模板的目的是为了提高复用性，将类型参数化；编译器根据调用的实参类型，在形参及结构体内自动生成对应的类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换整型变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换 double 型变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用模板交换变量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">double</span> c = <span class="number">1.1</span>, d = <span class="number">2.2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两种使用模板的方式</span></span><br><span class="line">	<span class="comment">// 1.自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);  <span class="comment">// 使用自动类型推导时候，要确保a和b的类型是一致的，否则编译错误</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">double</span>&gt;(c, d);  <span class="comment">// 但是这里&lt;&gt;里的类型必须与 c d 类型一直，否则编译不通过</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板必须要确定出 T 的数据类型，才可以使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func();  // 错误，模板不能独立使用，必须确定出 T 的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">// 利用显示指定类型的方式，给 T 一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例：利用函数模板，对不同数据类型数据从大到小进行排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])	max = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> number = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, number);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="1-2-普通函数与函数模板的区别"><a href="#1-2-普通函数与函数模板的区别" class="headerlink" title="1.2 普通函数与函数模板的区别"></a>1.2 普通函数与函数模板的区别</h2><p>​普通函数与函数模板区别：</p>
<ul>
<li><p>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</p>
</li>
<li><p>如果利用显示指定类型的方式，可以发生隐式类型转换</p>
</li>
<li><p>普通函数调用时可以发生自动类型转换（隐式类型转换）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">myAdd02</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;  <span class="comment">// c 对应的ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要注意和实参被 &amp; 修饰的区别：如果是引用修饰的实参，这里类型不一致也会报错</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl;  <span class="comment">// 109</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动类型转换，不会发生隐式类型转换</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl;  // 使用模板，不会发生自动类型转换，这里报错</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示指定类型</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c) &lt;&lt; endl;  <span class="comment">// 这里如果指定类型，则不会报错</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="1-3-普通函数与函数模板的调用规则"><a href="#1-3-普通函数与函数模板的调用规则" class="headerlink" title="1.3 普通函数与函数模板的调用规则"></a>1.3 普通函数与函数模板的调用规则</h2><p>‍</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数，如果只有声明，没有函数体实现，则会报错</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载，只要它们的形参表或类型参数表不同即可</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p>‍</p>
<p>函数模板和函数的调用次序：</p>
<ol>
<li>先找参数完全匹配的普通函数</li>
<li>再找参数完全匹配的模板函数</li>
<li>再找实参经过自动类型转换后能匹配的普通函数</li>
<li>都找到，报错</li>
</ol>
<p>‍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器，普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b);  <span class="comment">// 调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b);  <span class="comment">// 调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c);  <span class="comment">// 调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 因为这里 char 类型的会被</span></span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2);  <span class="comment">// 调用函数模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</strong></p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="1-4-模板的局限性"><a href="#1-4-模板的局限性" class="headerlink" title="1.4 模板的局限性"></a>1.4 模板的局限性</h2><ul>
<li>模板的通用性并不是万能的，如果下面的例子传入的参数是两个数组，则无法实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上述代码中，如果 T 的数据类型传入的是像 Person 的自定义数据类型，也无法正常运行。因此 C++ 为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体化，优先于普通模板。以 template&lt;&gt; 开头，并通过名称指出类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person&amp; p1, Person&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">// 内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)	cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">// 可以创建具体化的 Person 数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)	cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在 STL 能够运用系统提供的模板</li>
</ul>
</blockquote>
<hr>
<p>‍</p>
<h1 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2 类模板"></a>2 类模板</h1><ul>
<li>作用：建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)  <span class="comment">// 使用构造函数赋初值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定 NameType 为 string 类型，AgeType 为 int 类型</span></span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h2 id="2-1-类模板与函数模板区别"><a href="#2-1-类模板与函数模板区别" class="headerlink" title="2.1 类模板与函数模板区别"></a>2.1 类模板与函数模板区别</h2><p>‍</p>
<p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式（就是不能在参数列表里自动转换，如一个 int，一个 double），必须显式指定类型</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;  <span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误；类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;  <span class="comment">// 必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>)</span></span>;  <span class="comment">// 类模板中的模板参数列表，可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="2-2-类模板中成员函数创建时机"><a href="#2-2-类模板中成员函数创建时机" class="headerlink" title="2.2 类模板中成员函数创建时机"></a>2.2 类模板中成员函数创建时机</h2><p>类模板中成员函数和普通类中成员函数创建时机的区别：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以编译成功</span></span><br><span class="line">	<span class="comment">// 类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson2</span>();  <span class="comment">// Person1 中没有 showPerson2()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;  <span class="comment">// 说明 m 是 Person1 的对象</span></span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line">	<span class="comment">// showPerson2 不是 showPerson1 的成员</span></span><br><span class="line">	<span class="comment">// m.fun2();  // 编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="2-3-类模板对象做函数参数"><a href="#2-3-类模板对象做函数参数" class="headerlink" title="2.3 类模板对象做函数参数"></a>2.3 类模板对象做函数参数</h2><p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型    —   直接显式对象的数据类型</li>
<li>参数模板化          —   将对象中的参数变为模板进行传递</li>
<li>整个类模板化      —    将这个对象类型模板化进行传递</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定传入的类型（最常用）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span> &gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// string</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// Person string int</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="2-4-类模板与继承"><a href="#2-4-类模板与继承" class="headerlink" title="2.4 类模板与继承"></a>2.4 类模板与继承</h2><p>当类模板碰到继承时，需要注意：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T 的类型。如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中 T 的类型，子类也需变为类模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，c++ 编译需要给子类分配内存，必须知道父类中 T 的类型才可以向下继承</span></span><br><span class="line"><span class="comment">// class Son: public Base</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;  <span class="comment">// 必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想灵活指定出父类中 T 的类型，子类也需变为类模板</span></span><br><span class="line"><span class="comment">// 类模板继承类模板，用 T2 指定父类中的 T 类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Son2</span>: <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// int</span></span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// char</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="2-5-类模板成员函数类外实现"><a href="#2-5-类模板成员函数类外实现" class="headerlink" title="2.5 类模板成员函数类外实现"></a>2.5 类模板成员函数类外实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;  <span class="comment">// Person&lt;T1, T2&gt;:: 指定作用域（也就是谁的构造函数）</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="2-6-类模板分文件编写"><a href="#2-6-类模板分文件编写" class="headerlink" title="2.6 类模板分文件编写"></a>2.6 类模板分文件编写</h2><ul>
<li><p>如果有多个类，一般会将类写到一个单独的文件里</p>
</li>
<li><p>问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>解决方式1：直接包含 .cpp 源文件（一般不用）</li>
<li>解决方式2：将类的声明和实现写到一个名为 .hpp 得文件中，并不是强制</li>
</ul>
</li>
</ul>
<p>person.hpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方式1，包含cpp源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="2-7-类模板与友元"><a href="#2-7-类模板与友元" class="headerlink" title="2.7 类模板与友元"></a>2.7 类模板与友元</h2><ul>
<li><p>全局函数类内实现 - 直接在类内声明友元即可（最好用这个）</p>
</li>
<li><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板函数定义，因为这里需要 Person 类，所以，需要在该定义之前，声明 Person 类</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; <span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span>  <span class="comment">// 全局函数，没有必要加作用域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="comment">// 全局函数类外实现，需要提前让编译器知道全局函数的存在</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);  <span class="comment">// 必须要加空模板参数列表，否则只是普通函数，与类外的函数定义不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>‍</p>
<hr>
<h1 id="3-STL-初识"><a href="#3-STL-初识" class="headerlink" title="3 STL 初识"></a>3 STL 初识</h1><h2 id="3-1-STL-的诞生"><a href="#3-1-STL-的诞生" class="headerlink" title="3.1 STL 的诞生"></a>3.1 STL 的诞生</h2><ul>
<li>长久以来，软件界一直希望建立一种可重复利用的东西</li>
<li>C++ 的面向对象和泛型编程思想，目的就是复用性的提升</li>
<li>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li>
<li>为了建立数据结构和算法的一套标准，诞生了 STL</li>
</ul>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="3-2-STL-基本概念"><a href="#3-2-STL-基本概念" class="headerlink" title="3.2 STL 基本概念"></a>3.2 STL 基本概念</h2><ul>
<li>STL(Standard Template Library，<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为：容器(container)、算法(algorithm)、迭代器(iterator)</li>
<li>容器和算法之间通过迭代器进行无缝连接</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="3-3-STL-六大组件"><a href="#3-3-STL-六大组件" class="headerlink" title="3.3 STL 六大组件"></a>3.3 STL 六大组件</h2><ol>
<li><strong>容器</strong>：各种数据结构，如 vector、list、deque、set、map 等，用来存放数据</li>
<li><strong>算法</strong>：各种常用的算法，如 sort、find、copy、for_each 等</li>
<li><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理</li>
</ol>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="3-4-STL-中的容器、算法、迭代器"><a href="#3-4-STL-中的容器、算法、迭代器" class="headerlink" title="3.4 STL 中的容器、算法、迭代器"></a>3.4 STL 中的容器、算法、迭代器</h2><ul>
<li><p>容器：置物之所也</p>
</li>
<li><p>STL 容器就是将运用最广泛的一些数据结构实现出来，常用的数据结构：数组、链表、树、栈、队列、集合、映射表等。这些容器又分为序列式容器和关联式容器两种</p>
<ul>
<li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置</li>
<li>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系（但是可能有值的排序的可能）</li>
</ul>
</li>
<li><p>算法：问题之解法也</p>
</li>
<li><p>有限的步骤，解决逻辑或数学上的问题，叫做算法(Algorithms)。算法分为：质变算法和非质变算法</p>
<ul>
<li>质变算法：是指运算过程中<strong>会更改</strong>区间内的元素的内容，例如拷贝，替换，删除等</li>
<li>非质变算法：是指运算过程中<strong>不会更改</strong>区间内的元素内容，例如查找、计数、遍历、寻找极值等</li>
</ul>
</li>
<li><p>迭代器：容器和算法之间粘合剂，提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</p>
</li>
<li><p>每个容器都有自己专属的迭代器，迭代器使用非常类似于指针</p>
</li>
</ul>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th><strong>种类</strong></th>
<th><strong>功能</strong></th>
<th><strong>支持运算</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入迭代器</strong></td>
<td><strong>对数据的只读访问</strong></td>
<td><strong>只读，支持++、&#x3D;&#x3D;、！&#x3D;</strong></td>
</tr>
<tr>
<td><strong>输出迭代器</strong></td>
<td><strong>对数据的只写访问</strong></td>
<td><strong>只写，支持++</strong></td>
</tr>
<tr>
<td><strong>前向迭代器</strong></td>
<td><strong>读写操作，并能向前推进迭代器</strong></td>
<td><strong>读写，支持++、&#x3D;&#x3D;、！&#x3D;</strong></td>
</tr>
<tr>
<td><strong>双向迭代器</strong></td>
<td>读写操作，并能向前和向后操作</td>
<td></td>
</tr>
<tr>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td><strong>读写，支持++、–，</strong></td>
<td></td>
</tr>
<tr>
<td><strong>随机访问迭代器</strong></td>
<td></td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>三者关系：算法需要通过迭代器，才能访问容器中的元</strong></p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="3-5-容器算法迭代器初识"><a href="#3-5-容器算法迭代器初识" class="headerlink" title="3.5 容器算法迭代器初识"></a>3.5 容器算法迭代器初识</h2><p>STL 中最常用的容器为 Vector，可以理解为数组</p>
<p>容器：		vector</p>
<p>算法：		for_each</p>
<p>迭代器：		vector<int>::iterator</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建 vector 类型的容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">// 向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v.begin() 起始迭代器：返回指向容器中的第一个数据</span></span><br><span class="line">	<span class="comment">// v.end() 结束迭代器：返回指向容器的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">// vector&lt;int&gt;::iterator 中的 iterator 是迭代器名称</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一种遍历方式</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd)	cout &lt;&lt; (*pBegin) ++ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种遍历方式</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it ++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三种遍历方式</span></span><br><span class="line">	<span class="comment">// 使用 STL 提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);  <span class="comment">// 写函数名即可，因为利用了回调机制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>vector 中存放自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放自定义数据类型对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两种遍历方式都行</span></span><br><span class="line">	<span class="comment">// for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; it-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; it-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放自定义数据类型指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向容器中添加指针数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历容器中的数据，看 &lt;&gt; 中的是啥类型，取出来的就是啥类型的数据</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person* p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>Vector 容器嵌套容器，类似一个二维数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建小容器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向小容器中添加数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);  <span class="comment">// 1 2 3 4</span></span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);  <span class="comment">// 2 3 4 5</span></span><br><span class="line">		v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);  <span class="comment">// 3 4 5 6</span></span><br><span class="line">		v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);  <span class="comment">// 4 5 6 7</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将小容器元素插入到大容器中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为 *it 对应的 &lt;&gt; 也是一个小容器，所以需要再次遍历</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h1 id="4-常用容器"><a href="#4-常用容器" class="headerlink" title="4 常用容器"></a>4 常用容器</h1><h2 id="4-1-string-容器"><a href="#4-1-string-容器" class="headerlink" title="4.1 string 容器"></a>4.1 string 容器</h2><p>‍</p>
<p>本质：</p>
<ul>
<li>string 是 C++ 风格的字符串，而 string 本质上是一个类</li>
</ul>
<p>‍</p>
<p>string 和 char* 区别：</p>
<ul>
<li>char * 是一个指针</li>
<li>string 是一个类，类内部封装了 char<em>，</em>管理这个字符串，是一个 char 型的容器</li>
</ul>
<p>‍</p>
<p>特点：</p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找 find，拷贝 copy，删除 delete，替换 replace，插入 insert</p>
<p>string 管理 char* 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<hr>
<p>‍</p>
<h3 id="4-1-1-string-构造函数"><a href="#4-1-1-string-构造函数" class="headerlink" title="4.1.1 string 构造函数"></a>4.1.1 string 构造函数</h3><ul>
<li>​<code>string();</code>​       		             &#x2F;&#x2F; 创建一个空的字符串 例如: string str;</li>
<li>​<code>string(const char* s);</code>​**	     ​**&#x2F;&#x2F; 使用字符串 s 初始化</li>
<li>​<code>string(const string&amp; str);</code>​      &#x2F;&#x2F; 使用一个 string 对象初始化另一个 string 对象</li>
<li>​<code>string(int n, char c);</code>​             &#x2F;&#x2F; 使用 n 个字符 c 初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string 构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1;  <span class="comment">// 创建空字符串，调用无参构造函数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>;  <span class="comment">// 把 c_string 转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;  <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;  <span class="comment">// aaaaaaaaaa</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-1-2-string-赋值操作"><a href="#4-1-2-string-赋值操作" class="headerlink" title="4.1.2 string 赋值操作"></a>4.1.2 string 赋值操作</h3><p>赋值的函数原型：</p>
<ul>
<li>​<code>string&amp; operator=(const char* s);</code>​             &#x2F;&#x2F; char* 类型字符串 赋值给当前的字符串</li>
<li>​<code>string&amp; operator=(const string &amp;s);</code>​          &#x2F;&#x2F; 把字符串 s 赋给当前的字符串</li>
<li>​<code>string&amp; operator=(char c);</code>​                          &#x2F;&#x2F; 字符赋值给当前的字符串</li>
<li>​<code>string&amp; assign(const char *s);</code>​                   &#x2F;&#x2F; 把字符串 s 赋给当前的字符串</li>
<li>​<code>string&amp; assign(const char *s, int n);</code>​       &#x2F;&#x2F; 把字符串 s 的前 n 个字符赋给当前的字符串</li>
<li>​<code>string&amp; assign(const string &amp;s);</code>​                &#x2F;&#x2F; 把字符串 s 赋给当前字符串</li>
<li>​<code>string&amp; assign(int n, char c);</code>​                    &#x2F;&#x2F; 用 n 个字符 c 赋给当前字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;  <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;  <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 用的比较少</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;  <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;  <span class="comment">// hello c++</span></span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;  <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;  <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;  <span class="comment">// xxxxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-1-3-string-字符串拼接"><a href="#4-1-3-string-字符串拼接" class="headerlink" title="4.1.3 string 字符串拼接"></a>4.1.3 string 字符串拼接</h3><p>函数原型：</p>
<ul>
<li>​<code>string&amp; operator+=(const char* str);</code>​                   &#x2F;&#x2F; 重载+&#x3D;操作符</li>
<li>​<code>string&amp; operator+=(const char c);</code>​                         &#x2F;&#x2F; 重载+&#x3D;操作符</li>
<li>​<code>string&amp; operator+=(const string&amp; str);</code>​                &#x2F;&#x2F; 重载+&#x3D;操作符</li>
<li>​<code>string&amp; append(const char *s);</code>​                              &#x2F;&#x2F; 把字符串 s 连接到当前字符串结尾</li>
<li>​<code>string&amp; append(const char *s, int n);</code>​                  &#x2F;&#x2F; 把字符串 s 的前 n 个字符连接到当前字符串结尾</li>
<li>​<code>string&amp; append(const string &amp;s);</code>​                           &#x2F;&#x2F; 同 operator+&#x3D;(const string&amp; str)</li>
<li>​<code>string&amp; append(const string &amp;s, int pos, int n);</code>​ &#x2F;&#x2F; 字符串 s 中从 pos 开始的n个字符连接到字符串结尾</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;  <span class="comment">// str1 = 我爱玩游戏</span></span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;  <span class="comment">// str1 = 我爱玩游戏:</span></span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;  <span class="comment">// str1 = 我爱玩游戏:LOL DNF</span></span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);  <span class="comment">// I love game</span></span><br><span class="line">	<span class="comment">// str3.append(str2);</span></span><br><span class="line">	str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>);  <span class="comment">// 从下标 4 位置开始 ，截取 3 个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;  <span class="comment">// I love gameDNF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-1-4-string-查找和替换"><a href="#4-1-4-string-查找和替换" class="headerlink" title="4.1.4 string 查找和替换"></a>4.1.4 string 查找和替换</h3><ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p>函数原型：</p>
<ul>
<li>​<code>int find(const string&amp; str, int pos = 0) const;</code>​              &#x2F;&#x2F; 查找 str 第一次出现位置，从 pos 开始查找</li>
<li>​<code>int find(const char* s, int pos = 0) const;</code>​                     &#x2F;&#x2F; 查找 s 第一次出现位置，从 pos 开始查找</li>
<li>​<code>int find(const char* s, int pos, int n) const;</code>​                &#x2F;&#x2F; 从 pos 位置查找s的前n个字符第一次位置</li>
<li>​<code>int find(const char c, int pos = 0) const;</code>​                       &#x2F;&#x2F; 查找字符 c 第一次出现位置</li>
<li>​<code>int rfind(const string&amp; str, int pos = npos) const;</code>​       &#x2F;&#x2F; 查找 str 最后一次位置，从 pos 开始查找</li>
<li>​<code>int rfind(const char* s, int pos = npos) const;</code>​              &#x2F;&#x2F; 查找 s 最后一次出现位置，从 pos 开始查找</li>
<li>​<code>int rfind(const char* s, int pos, int n) const;</code>​               &#x2F;&#x2F; 从 pos 查找 s 的前 n 个字符最后一次位置</li>
<li>​<code>int rfind(const char c, int pos = 0) const;</code>​                      &#x2F;&#x2F; 查找字符 c 最后一次出现位置</li>
<li>​<code>string&amp; replace(int pos, int n, const string&amp; str);</code>​        &#x2F;&#x2F; 替换从 pos 开始 n 个字符为字符串 str</li>
<li>​<code>string&amp; replace(int pos, int n,const char* s);</code>​                 &#x2F;&#x2F; 替换从 pos 开始的 n 个字符为字符串 s</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从左往右查</span></span><br><span class="line">	<span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);  <span class="comment">// 如果正确查找，返回下标；否则，返回 -1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未找到</span></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 正确查找</span></span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);  <span class="comment">// 从右往左查找</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);  <span class="comment">// 从下标 1 起 3 个字符，替换为 1111</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;  <span class="comment">// a1111efg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li>find 查找是从左往后，rfind 从右往左</li>
<li>find 找到字符串后返回查找的第一个字符位置，找不到返回 -1</li>
<li>replace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-1-5-string-字符串比较"><a href="#4-1-5-string-字符串比较" class="headerlink" title="4.1.5 string 字符串比较"></a>4.1.5 string 字符串比较</h3><ul>
<li>比较方式：按字符的 ASCII 码进行对比</li>
</ul>
<p>等于 &#x3D; 返回 0</p>
<p>大于 &gt; 返回 1</p>
<p>小于 &lt; 返回 -1</p>
<p>函数原型：</p>
<ul>
<li>​<code>int compare(const string&amp; s) const;</code>​  &#x2F;&#x2F; 与字符串 s 比较</li>
<li>​<code>int compare(const char* s) const;</code>​      &#x2F;&#x2F; 与字符串 s 比较</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) 	cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) 	cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> 	cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：字符串对比主要是用于比较两个字符串<strong>是否相等</strong>，判断谁大谁小的意义并不是很大</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-1-6-string-字符存取"><a href="#4-1-6-string-字符存取" class="headerlink" title="4.1.6 string 字符存取"></a>4.1.6 string 字符存取</h3><p>‍</p>
<p>string 中单个字符存取方式有两种</p>
<ul>
<li>​<code>char&amp; operator[](int n);</code>​      &#x2F;&#x2F; 通过 [] 方式取字符</li>
<li>​<code>char&amp; at(int n);</code>​                    &#x2F;&#x2F; 通过 at 方法获取字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 [] 方式取字符</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)	cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// h e l l o</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 at 方法获取字符</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)	cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// h e l l o</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改单个字符</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// x x l l o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-1-7-string-插入和删除"><a href="#4-1-7-string-插入和删除" class="headerlink" title="4.1.7 string 插入和删除"></a>4.1.7 string 插入和删除</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>string&amp; insert(int pos, const char* s);</code>​                &#x2F;&#x2F; 插入字符串</li>
<li>​<code>string&amp; insert(int pos, const string&amp; str);</code>​         &#x2F;&#x2F; 插入字符串</li>
<li>​<code>string&amp; insert(int pos, int n, char c);</code>​                &#x2F;&#x2F; 在指定位置插入 n 个字符 c</li>
<li>​<code>string&amp; erase(int pos, int n = npos);</code>​                    &#x2F;&#x2F; 删除从 Pos 开始的 n 个字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// h111ello</span></span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 从 1 号位置开始删除 3 个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-1-8-string-获取子串"><a href="#4-1-8-string-获取子串" class="headerlink" title="4.1.8 string 获取子串"></a>4.1.8 string 获取子串</h3><p>‍</p>
<p>函数原型：</p>
<p>​<code>string substr(int pos = 0, int n = npos) const;</code>​   &#x2F;&#x2F; 返回由 pos 开始的 n 个字符组成的字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;  <span class="comment">// bcd</span></span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;zhangsan@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);  <span class="comment">// 按字符查找，返回开始的下标</span></span><br><span class="line">	cout &lt;&lt; pos &lt;&lt; endl;  <span class="comment">// 8</span></span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);  <span class="comment">// 截取名字子串</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;  <span class="comment">// username: zhangsan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="4-2-vector-容器"><a href="#4-2-vector-容器" class="headerlink" title="4.2 vector 容器"></a>4.2 vector 容器</h2><p>‍</p>
<ul>
<li>功能：vector 数据结构和数组非常相似，也称为单端数组</li>
<li>vector 与普通数组区别：不同之处在于数组是静态空间，而 vector 可以<strong>动态扩展</strong></li>
<li>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间；vector 容器的迭代器支持随机访问</li>
</ul>
<p><img src="/assets/image-20230526203321-e2f5yoz.png" alt="image"></p>
<hr>
<p>‍</p>
<h3 id="4-2-1-vector-构造函数"><a href="#4-2-1-vector-构造函数" class="headerlink" title="4.2.1 vector 构造函数"></a>4.2.1 vector 构造函数</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>vector&lt;T&gt; v;</code>​                                  &#x2F;&#x2F; 采用模板实现类实现，默认构造函数</li>
<li>​<code>vector(v.begin(), v.end());</code>​        &#x2F;&#x2F; 将 v[begin(), end()) 区间中的元素拷贝给本身</li>
<li>​<code>vector(n, elem);</code>​                           &#x2F;&#x2F; 构造函数将 n 个 elem 拷贝给本身</li>
<li>​<code>vector(const vector &amp;vec);</code>​          &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;  <span class="comment">// 无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v1.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过区间方式进行构造</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// n 个 elem 方式构造</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-2-2-vector-赋值操作"><a href="#4-2-2-vector-赋值操作" class="headerlink" title="4.2.2 vector 赋值操作"></a>4.2.2 vector 赋值操作</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>vector&amp; operator=(const vector &amp;vec);</code>​   &#x2F;&#x2F; 重载等号操作符</li>
<li>​<code>assign(beg, end);</code>​                                      &#x2F;&#x2F; 将 [beg, end) 区间中的数据拷贝赋值给本身<strong>（注意这里与 string 的不同）</strong></li>
<li>​<code>assign(n, elem);</code>​                                        &#x2F;&#x2F; 将 n 个 elem 拷贝赋值给本身</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;  <span class="comment">// 无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">	v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-2-3-vector-容量和大小"><a href="#4-2-3-vector-容量和大小" class="headerlink" title="4.2.3 vector 容量和大小"></a>4.2.3 vector 容量和大小</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>empty();</code>​                                 &#x2F;&#x2F; 判断容器是否为空</li>
<li>​<code>capacity();</code>​                            &#x2F;&#x2F; 容器的容量（随机开辟）</li>
<li>​<code>size();</code>​                                   &#x2F;&#x2F; 返回容器中元素的个数</li>
<li>​<code>resize(int num);</code>​                    &#x2F;&#x2F; 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
<li>​<code>resize(int num, elem);</code>​          &#x2F;&#x2F; 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容器为空</span></span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">empty</span>())	cout &lt;&lt; <span class="string">&quot;v1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1 的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 13</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1 的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新指定大小，若指定的更大，用 10 填充，默认用 0 填充新位置</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9 10 10 10 10 10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-2-4-vector-插入和删除"><a href="#4-2-4-vector-插入和删除" class="headerlink" title="4.2.4 vector 插入和删除"></a>4.2.4 vector 插入和删除</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>push_back(ele);</code>​                                                             &#x2F;&#x2F; 尾部插入元素 ele</li>
<li>​<code>pop_back();</code>​                                                                   &#x2F;&#x2F; 删除最后一个元素</li>
<li>​<code>insert(const_iterator pos, ele);</code>​                               &#x2F;&#x2F; 迭代器指向位置 pos 插入元素 ele</li>
<li>​<code>insert(const_iterator pos, int count,ele);</code>​               &#x2F;&#x2F; 迭代器指向位置 pos 插入 count 个元素 ele</li>
<li>​<code>erase(const_iterator pos);</code>​                                           &#x2F;&#x2F; 删除迭代器指向的元素</li>
<li>​<code>erase(const_iterator start, const_iterator end);</code>​     &#x2F;&#x2F; 删除迭代器从 start 到 end之间的元素</li>
<li>​<code>clear();</code>​                                                                           &#x2F;&#x2F; 删除容器中所有元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尾删</span></span><br><span class="line">	v1.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);  <span class="comment">// 把 100 插入到第一个参数的位置</span></span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 100 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);  <span class="comment">// 限定插入长度</span></span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 1000 1000 100 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除，参数也是迭代器</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 1000 100 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清空</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());  <span class="comment">// 从头到尾全部删除</span></span><br><span class="line">	v1.<span class="built_in">clear</span>();  <span class="comment">// 不用提供参数</span></span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-2-5-vector-数据存取"><a href="#4-2-5-vector-数据存取" class="headerlink" title="4.2.5 vector 数据存取"></a>4.2.5 vector 数据存取</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>at(int idx);</code>​              &#x2F;&#x2F; 返回索引 idx 所指的数据</li>
<li>​<code>operator[];</code>​               &#x2F;&#x2F; 返回索引 idx 所指的数据</li>
<li>​<code>front();</code>​                    &#x2F;&#x2F; 返回容器中第一个数据元素</li>
<li>​<code>back();</code>​                      &#x2F;&#x2F; 返回容器中最后一个数据元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v1.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用 [] 访问数组中元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)	cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用 at 方式访问元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)	cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1 的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1 的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;  <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-2-6-vector-互换容器"><a href="#4-2-6-vector-互换容器" class="headerlink" title="4.2.6 vector 互换容器"></a>4.2.6 vector 互换容器</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>swap(vec); ​</code>​                              &#x2F;&#x2F; 将 vec 与本身的元素互换（实际用途：使用 swap 可以收缩内存空间）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)	v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);  <span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);  <span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line">	<span class="built_in">printVector</span>(v2);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际用途：使用 swap 可以收缩内存空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)	v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 138255</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 100000</span></span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);  <span class="comment">// 重新指定大小</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v 的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 138255</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v 的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line">	<span class="comment">// vector&lt;int&gt;(v) -- 匿名对象：当前行使用完，系统立马回收内存空间</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v 的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v 的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-2-7-vector-预留空间"><a href="#4-2-7-vector-预留空间" class="headerlink" title="4.2.7 vector 预留空间"></a>4.2.7 vector 预留空间</h3><p>‍</p>
<ul>
<li>功能：减少 vector 在动态扩展容量时的扩展次数</li>
</ul>
<p>函数原型：</p>
<ul>
<li>​<code>reserve(int len);</code>​                   &#x2F;&#x2F; 容器预留 len 个元素长度，预留位置未初始化，元素不可访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;  <span class="comment">// 统计开辟次数</span></span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里说的是，在遍历创建容器的时候，并不是一次性就把内存空间确定好了的</span></span><br><span class="line">	<span class="comment">// 因为 vector 会动态扩展，如果内存满了的话，下面的遍历会进行多次开辟内存操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没预留空间的话，num 是 30，开辟了 30 次内存空间</span></span><br><span class="line">	<span class="comment">// 如果预留空间，num 是 1，只开辟了一次内存空间</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果数据量较大，可以一开始利用 reserve 预留空间</p>
</blockquote>
<hr>
<p>‍</p>
<h2 id="4-3-deque-容器"><a href="#4-3-deque-容器" class="headerlink" title="4.3 deque 容器"></a>4.3 deque 容器</h2><p>‍</p>
<p>功能：</p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p>特点：</p>
<ul>
<li>支持随机访问</li>
</ul>
<p>‍</p>
<p>deque 与 vector 区别：</p>
<ul>
<li>vector 对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque 相对而言，对<strong>头部的插入删除</strong>速度回比 vector 快</li>
<li>vector 访问元素时的速度会比 deque 快（vector 是一块连续的内存空间）</li>
</ul>
<p><img src="/assets/image-20230526212005-e887mkw.png" alt="image"></p>
<p>deque 内部工作原理：</p>
<ul>
<li>deque 内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</li>
<li>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</li>
</ul>
<p><img src="/assets/image-20230526212113-0mya2ix.png" alt="image">​​</p>
<hr>
<p>‍</p>
<h3 id="4-3-1-deque-构造函数"><a href="#4-3-1-deque-构造函数" class="headerlink" title="4.3.1 deque 构造函数"></a>4.3.1 deque 构造函数</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>deque&lt;T&gt; deqT;</code>​                                      &#x2F;&#x2F; 默认构造形式</li>
<li>​<code>deque(beg, end);</code>​                                   &#x2F;&#x2F; 构造函数将 [beg, end) 区间中的元素拷贝给本身</li>
<li>​<code>deque(n, elem);</code>​                                     &#x2F;&#x2F; 构造函数将 n 个 elem 拷贝给本身</li>
<li>​<code>deque(const deque &amp;deq);</code>​                      &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span>  <span class="comment">// 限定只读状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 不能从 const iterator -&gt; iterator，所以，需要更改 const_iterator</span></span><br><span class="line">	<span class="comment">// 添加了 const 之后，元素的值就不能修改了</span></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deque 构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;  <span class="comment">// 无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 区间方式构造</span></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// n 个 elem 元素拷贝给本身</span></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造</span></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-3-2-deque-赋值操作"><a href="#4-3-2-deque-赋值操作" class="headerlink" title="4.3.2 deque 赋值操作"></a>4.3.2 deque 赋值操作</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>deque&amp; operator=(const deque&amp; deq);</code>​                                 &#x2F;&#x2F; 重载等号操作符</li>
<li>​<code>assign(beg, end);</code>​                                                                &#x2F;&#x2F; 将 [beg, end) 区间中的数据拷贝赋值给本身</li>
<li>​<code>assign(n, elem);</code>​                                                                  &#x2F;&#x2F; 将 n 个 elem 拷贝赋值给本身</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span>  <span class="comment">// 限定只读状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d3;</span><br><span class="line">	d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d4;</span><br><span class="line">	d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-3-3-deque-大小操作"><a href="#4-3-3-deque-大小操作" class="headerlink" title="4.3.3 deque 大小操作"></a>4.3.3 deque 大小操作</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>deque.empty();</code>​                              &#x2F;&#x2F; 判断容器是否为空</li>
<li>​<code>deque.size();</code>​                               &#x2F;&#x2F; 返回容器中元素的个数</li>
<li>​<code>deque.resize(num);</code>​                       &#x2F;&#x2F; 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
<li>​<code>deque.resize(num, elem);</code>​             &#x2F;&#x2F; 重新指定容器的长度为num，若容器变长，则以 elem 值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<p>注意：</p>
<ul>
<li>因为 deque 使用的是中控继的方式，所以它没有容量，只有容器大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d1.<span class="built_in">empty</span>())	cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1 不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1 的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新指定大小</span></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h3 id="4-3-4-deque-插入和删除"><a href="#4-3-4-deque-插入和删除" class="headerlink" title="4.3.4 deque 插入和删除"></a>4.3.4 deque 插入和删除</h3><p>‍</p>
<p>两端插入操作：</p>
<ul>
<li>​<code>push_back(elem);</code>​​                         &#x2F;&#x2F; 在容器尾部添加一个数据</li>
<li>​<code>push_front(elem);</code>​​                        &#x2F;&#x2F; 在容器头部插入一个数据</li>
<li>​<code>pop_back();</code>​​                                  &#x2F;&#x2F; 删除容器最后一个数据</li>
<li>​<code>pop_front();</code>​​                                &#x2F;&#x2F; 删除容器第一个数据</li>
</ul>
<p>‍</p>
<p>指定位置操作：</p>
<ul>
<li>​<code>insert(pos,elem);</code>​                          &#x2F;&#x2F; 在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置</li>
<li>​<code>insert(pos,n,elem);</code>​                       &#x2F;&#x2F; 在 pos 位置插入 n 个 elem 数据，无返回值</li>
<li>​<code>insert(pos,beg,end);</code>​                     &#x2F;&#x2F; 在 pos 位置插入 [beg, end) 区间的数据，无返回值</li>
<li>​<code>clear();</code>​                                          &#x2F;&#x2F; 清空容器的所有数据</li>
<li>​<code>erase(beg,end);</code>​                              &#x2F;&#x2F; 删除 [beg,end) 区间的数据，返回下一个数据的位置</li>
<li>​<code>erase(pos);</code>​                                     &#x2F;&#x2F; 删除 pos 位置的数据，返回下一个数据的位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="comment">// 尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);  </span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">// 头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 200 100 10 20 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();  <span class="comment">// 200 100 10</span></span><br><span class="line">	<span class="comment">// 头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 100 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 200 100 10 20 </span></span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 1000 200 100 10 20 </span></span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 10000 10000 1000 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 1 2 3 10000 10000 1000 200 100 10 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());  </span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 100 10 20</span></span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-3-5-deque-数据存取"><a href="#4-3-5-deque-数据存取" class="headerlink" title="4.3.5 deque 数据存取"></a>4.3.5 deque 数据存取</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>at(int idx);</code>​                                                &#x2F;&#x2F; 返回索引 idx 所指的数据</li>
<li>​<code>operator[];</code>​                                                 &#x2F;&#x2F; 返回索引 idx 所指的数据</li>
<li>​<code>front();</code>​                                                      &#x2F;&#x2F; 返回容器中第一个数据元素</li>
<li>​<code>back();</code>​                                                        &#x2F;&#x2F; 返回容器中最后一个数据元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++)	cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++)	cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">// 300</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-3-6-deque-排序"><a href="#4-3-6-deque-排序" class="headerlink" title="4.3.6 deque 排序"></a>4.3.6 deque 排序</h3><p>‍</p>
<p>算法：</p>
<ul>
<li>​<code>sort(iterator beg, iterator end)</code>​            &#x2F;&#x2F; 对 beg 和 end 区间内元素进行排序（支持随机访问迭代器的容器，都可以使用 sort 算法）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 200 100 10 20</span></span><br><span class="line">	<span class="comment">// 排序算法：默认从小到大排</span></span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);  <span class="comment">// 10 20 100 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>注意：</p>
<ul>
<li>因为 vector 更像一个数组，因此，它比 deque 多一个 capacity 属性</li>
</ul>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="4-4-stack-和-queue-容器"><a href="#4-4-stack-和-queue-容器" class="headerlink" title="4.4 stack 和 queue 容器"></a>4.4 stack 和 queue 容器</h2><p>‍</p>
<h3 id="4-4-1-stack-容器"><a href="#4-4-1-stack-容器" class="headerlink" title="4.4.1 stack 容器"></a>4.4.1 stack 容器</h3><p>‍</p>
<ul>
<li>概念：stack 是一种先进后出 (First In Last Out,FILO) 的数据结构</li>
</ul>
<p><img src="/assets/image-20230526215730-gp3lbob.png" alt="image"></p>
<ul>
<li><p>栈中只有顶端的元素才可以被外界使用，因此<strong>栈不允许有遍历行为</strong></p>
</li>
<li><p>栈中进入数据称为 — <strong>入栈</strong> <code>push</code>​</p>
</li>
<li><p>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code>​</p>
</li>
</ul>
<hr>
<p>‍</p>
<p>常用接口：</p>
<p>‍</p>
<p>构造函数：</p>
<ul>
<li>​<code>stack&lt;T&gt; stk;</code>​                            &#x2F;&#x2F; stack 采用模板类实现， stack 对象的默认构造形式</li>
<li>​<code>stack(const stack &amp;stk);</code>​         &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<p>‍</p>
<p>赋值操作：</p>
<ul>
<li>​<code>stack&amp; operator=(const stack &amp;stk);</code>​            &#x2F;&#x2F; 重载等号操作符</li>
</ul>
<p>‍</p>
<p>数据存取：</p>
<ul>
<li>​<code>push(elem);</code>​                               &#x2F;&#x2F; 向栈顶添加元素</li>
<li>​<code>pop();</code>​                                        &#x2F;&#x2F; 从栈顶移除第一个元素</li>
<li>​<code>top();&lt;span&gt; &lt;/span&gt;</code>​                &#x2F;&#x2F; 返回栈顶元素</li>
</ul>
<p>‍</p>
<p>大小操作：</p>
<ul>
<li>​<code>empty();</code>​                                      &#x2F;&#x2F; 判断堆栈是否为空</li>
<li>​<code>size();</code>​                                        &#x2F;&#x2F; 返回栈的大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建栈容器，栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向栈中添加元素，叫做压栈、入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">// 输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">// 弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-4-2-queue-容器"><a href="#4-4-2-queue-容器" class="headerlink" title="4.4.2 queue 容器"></a>4.4.2 queue 容器</h3><p>概念：Queue 是一种先进先出 (First In First Out,FIFO) 的数据结构，它有两个出口</p>
<p><img src="/assets/image-20230526220333-25rze8p.png" alt="image"></p>
<ul>
<li><p>队列容器允许从一端新增元素，从另一端移除元素</p>
</li>
<li><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
</li>
<li><p>队列中进数据称为 — <strong>入队</strong> <code>push</code>​</p>
</li>
<li><p>队列中出数据称为 — <strong>出队</strong> <code>pop</code>​</p>
</li>
</ul>
<hr>
<p>‍</p>
<p>常用接口：</p>
<p>‍</p>
<p>构造函数：</p>
<ul>
<li>​<code>queue&lt;T&gt; que;</code>​                           &#x2F;&#x2F; queue采用模板类实现，queue 对象的默认构造形式</li>
<li>​<code>queue(const queue &amp;que);</code>​        &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<p>‍</p>
<p>赋值操作：</p>
<ul>
<li>​<code>queue&amp; operator=(const queue &amp;que);</code>​     &#x2F;&#x2F; 重载等号操作符</li>
</ul>
<p>‍</p>
<p>数据存取：</p>
<ul>
<li>​<code>push(elem);</code>​                                      &#x2F;&#x2F; 往队尾添加元素</li>
<li>​<code>pop();</code>​                                               &#x2F;&#x2F; 从队头移除第一个元素</li>
<li>​<code>back();</code>​                                             &#x2F;&#x2F; 返回最后一个元素</li>
<li>​<code>front();&lt;span&gt; &lt;/span&gt;</code>​                   &#x2F;&#x2F; 返回第一个元素</li>
</ul>
<p>‍</p>
<p>大小操作：</p>
<ul>
<li>​<code>empty();</code>​                               &#x2F;&#x2F; 判断堆栈是否为空</li>
<li>​<code>size();</code>​                                 &#x2F;&#x2F; 返回栈的大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line">	<span class="comment">// 准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向队列中添加元素，入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 队列不提供迭代器，更不支持随机访问</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">// 输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">// 弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h2 id="4-5-list-容器"><a href="#4-5-list-容器" class="headerlink" title="4.5 list 容器"></a>4.5 list 容器</h2><p>‍</p>
<p>功能：将数据进行链式存储</p>
<p>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列结点组成</p>
<p>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p>STL 中的链表是一个双向循环链表</p>
<p><img src="/assets/image-20230526220803-srw78q5.png" alt="image"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持<strong>前移和后移</strong>，属于双向迭代器</p>
<p>‍</p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>‍</p>
<p>list 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的</p>
<p>‍</p>
<blockquote>
<p>总结：STL 中 list 和 vector 是两个最常被使用的容器，各有优缺点</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-5-1-list-构造函数"><a href="#4-5-1-list-构造函数" class="headerlink" title="4.5.1 list 构造函数"></a>4.5.1 list 构造函数</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>list&lt;T&gt; lst;</code>​                         &#x2F;&#x2F; list 采用采用模板类实现，对象的默认构造形式</li>
<li>​<code>list(beg,end);</code>​                     &#x2F;&#x2F; 构造函数将 [beg, end) 区间中的元素拷贝给本身</li>
<li>​<code>list(n,elem);</code>​                       &#x2F;&#x2F; 构造函数将 n 个 elem 拷贝给本身</li>
<li>​<code>list(const list &amp;lst);</code>​        &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L1;  <span class="comment">// ，默认构造</span></span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);  <span class="comment">// 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照区间方式构造</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(),L1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printList</span>(L2);  <span class="comment">// 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">	<span class="built_in">printList</span>(L3);  <span class="comment">// 10 20 30 40</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// n 个 elem 拷贝方式</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);  <span class="comment">// 100 100 100 100 100 100 100 100 100 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-5-2-list-赋值和交换"><a href="#4-5-2-list-赋值和交换" class="headerlink" title="4.5.2 list 赋值和交换"></a>4.5.2 list 赋值和交换</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>assign(beg, end);</code>​                                   &#x2F;&#x2F; 将 [beg, end) 区间中的数据拷贝赋值给本身</li>
<li>​<code>assign(n, elem);</code>​                                     &#x2F;&#x2F; 将 n 个 elem 拷贝赋值给本身</li>
<li>​<code>list&amp; operator=(const list &amp;lst);</code>​        &#x2F;&#x2F; 重载等号操作符</li>
<li>​<code>swap(lst);</code>​                                               &#x2F;&#x2F; 将 lst 与本身的元素互换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L3;</span><br><span class="line">	L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L4;</span><br><span class="line">	L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L2;</span><br><span class="line">	L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">swap</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-5-3-list-大小操作"><a href="#4-5-3-list-大小操作" class="headerlink" title="4.5.3 list 大小操作"></a>4.5.3 list 大小操作</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>size();</code>​                                   &#x2F;&#x2F; 返回容器中元素的个数</li>
<li>​<code>empty();</code>​                                  &#x2F;&#x2F; 判断容器是否为空</li>
<li>​<code>resize(num);</code>​                           &#x2F;&#x2F; 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
<li>​<code>resize(num, elem);</code>​                 &#x2F;&#x2F; 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L1.<span class="built_in">empty</span>())	cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新指定大小</span></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-5-4-list-插入和删除"><a href="#4-5-4-list-插入和删除" class="headerlink" title="4.5.4 list 插入和删除"></a>4.5.4 list 插入和删除</h3><p>‍</p>
<p><strong>函数原型：</strong></p>
<ul>
<li>​<code>push_back(elem);</code>​                       &#x2F;&#x2F; 在容器尾部加入一个元素</li>
<li>​<code>pop_back();</code>​                                &#x2F;&#x2F; 删除容器中最后一个元素</li>
<li>​<code>push_front(elem);</code>​                      &#x2F;&#x2F; 在容器开头插入一个元素</li>
<li>​<code>pop_front();</code>​                               &#x2F;&#x2F; 从容器开头移除第一个元素</li>
<li>​<code>insert(pos,elem);</code>​                       &#x2F;&#x2F; 在 pos 位置插 elem 元素的拷贝，返回新数据的位置</li>
<li>​<code>insert(pos,n,elem);</code>​                   &#x2F;&#x2F; 在 pos 位置插入 n 个 elem 数据，无返回值</li>
<li>​<code>insert(pos,beg,end);</code>​                  &#x2F;&#x2F; 在 pos 位置插入 [beg,end) 区间的数据，无返回值</li>
<li>​<code>clear();</code>​                                       &#x2F;&#x2F; 移除容器的所有数据</li>
<li>​<code>erase(beg,end);</code>​                           &#x2F;&#x2F; 删除 [beg,end) 区间的数据，返回下一个数据的位置</li>
<li>​<code>erase(pos);</code>​                                  &#x2F;&#x2F; 删除 pos 位置的数据，返回下一个数据的位置</li>
<li>​<code>remove(elem);</code>​​                               &#x2F;&#x2F; 删除容器中<strong>所有</strong>与 elem 值匹配的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">// 尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">// 头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">  </span><br><span class="line">    	<span class="comment">// 清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：list 多了一个 remove 方法，删除指定元素</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="4-5-5-list-数据存取"><a href="#4-5-5-list-数据存取" class="headerlink" title="4.5.5 list 数据存取"></a>4.5.5 list 数据存取</h3><p>函数原型：</p>
<ul>
<li>​<code>front();</code>​           &#x2F;&#x2F; 返回第一个元素</li>
<li>​<code>back();</code>​             &#x2F;&#x2F; 返回最后一个元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cout &lt;&lt; L1.at(0) &lt;&lt; endl;  // 错误，不支持 at 访问数据</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; L1[0] &lt;&lt; endl;  // 错误，不支持 [] 方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// list 容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">// it = it + 1;  // 错误，不可以跳跃访问，即使是 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：list 容器中不可以通过 [] 或者 at 方式访问数据</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-5-6-list-反转和排序"><a href="#4-5-6-list-反转和排序" class="headerlink" title="4.5.6 list 反转和排序"></a>4.5.6 list 反转和排序</h3><p>函数原型：</p>
<ul>
<li>​<code>reverse();</code>​                          &#x2F;&#x2F; 反转链表</li>
<li>​<code>sort();</code>​                               &#x2F;&#x2F; 链表排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span>	</span>&#123; <span class="keyword">return</span> val1 &gt; val2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);  <span class="comment">// 90 30 20 70</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);  <span class="comment">// 70 20 30 90</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>();  <span class="comment">// 默认的排序规则，从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);  <span class="comment">// 20 30 70 90</span></span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare);  <span class="comment">// 指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);  <span class="comment">// 90 70 30 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="4-6-set-x2F-multiset-容器"><a href="#4-6-set-x2F-multiset-容器" class="headerlink" title="4.6 set&#x2F;multiset 容器"></a>4.6 set&#x2F;multiset 容器</h2><p>‍</p>
<p>set 简介：</p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p>‍</p>
<p>set 本质：</p>
<ul>
<li>set&#x2F;multiset 属于关联式容器，底层结构是用二叉树实现</li>
</ul>
<p>‍</p>
<p>set 和 multiset 区别：</p>
<ul>
<li>set 不允许容器中有重复的元素</li>
<li>multiset 允许容器中有重复的元素</li>
</ul>
<hr>
<p>‍</p>
<h3 id="4-6-1-set-构造和赋值"><a href="#4-6-1-set-构造和赋值" class="headerlink" title="4.6.1 set 构造和赋值"></a>4.6.1 set 构造和赋值</h3><p>‍</p>
<p>构造：</p>
<ul>
<li>​<code>set&lt;T&gt; st;</code>​                             &#x2F;&#x2F; 默认构造函数</li>
<li>​<code>set(const set &amp;st);</code>​              &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<p>‍</p>
<p>赋值：</p>
<ul>
<li>​<code>set&amp; operator=(const set &amp;st);</code>​     &#x2F;&#x2F; 重载等号操作符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li>set 容器插入数据时用 insert</li>
<li>set 容器插入数据的数据会自动排序</li>
</ul>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-6-2-set-大小和交换"><a href="#4-6-2-set-大小和交换" class="headerlink" title="4.6.2 set 大小和交换"></a>4.6.2 set 大小和交换</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>size();</code>​               &#x2F;&#x2F; 返回容器中元素的数目</li>
<li>​<code>empty();</code>​             &#x2F;&#x2F; 判断容器是否为空</li>
<li>​<code>swap(st);</code>​           &#x2F;&#x2F; 交换两个集合容器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">empty</span>())	cout &lt;&lt; <span class="string">&quot;s1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-6-3-set-插入和删除"><a href="#4-6-3-set-插入和删除" class="headerlink" title="4.6.3 set 插入和删除"></a>4.6.3 set 插入和删除</h3><p>函数原型：</p>
<ul>
<li>​<code>insert(elem);</code>​             &#x2F;&#x2F; 在容器中插入元素</li>
<li>​<code>clear();</code>​                      &#x2F;&#x2F; 清除所有元素</li>
<li>​<code>erase(pos);</code>​                 &#x2F;&#x2F; 删除 pos 迭代器所指的元素，返回下一个元素的迭代器</li>
<li>​<code>erase(beg, end);</code>​         &#x2F;&#x2F; 删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器</li>
<li>​<code>erase(elem);</code>​                &#x2F;&#x2F; 删除容器中值为 elem 的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清空</span></span><br><span class="line">	<span class="comment">// s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-6-4-set-查找和统计"><a href="#4-6-4-set-查找和统计" class="headerlink" title="4.6.4 set 查找和统计"></a>4.6.4 set 查找和统计</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>find(key);</code>​          &#x2F;&#x2F; 查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 set.end();</li>
<li>​<code>count(key);</code>​         &#x2F;&#x2F; 统计 key 的元素个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);  <span class="comment">// 注意：因为返回的是元素的迭代器，取值的话要用 * </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计</span></span><br><span class="line">	<span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-6-5-set-和-multiset-区别"><a href="#4-6-5-set-和-multiset-区别" class="headerlink" title="4.6.5 set 和 multiset 区别"></a>4.6.5 set 和 multiset 区别</h3><p>‍</p>
<p>区别：</p>
<ul>
<li>set 不可以插入重复数据，而 multiset 可以</li>
<li>set 插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset 不会检测数据，因此可以插入重复数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set 和 multiset 区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 第一次插入成功!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret.second)	cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 第二次插入失败!</span></span><br><span class="line">	<span class="keyword">if</span> (ret.second)	cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 10 10</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-6-6-pair-对组创建"><a href="#4-6-6-pair-对组创建" class="headerlink" title="4.6.6 pair 对组创建"></a>4.6.6 pair 对组创建</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p>‍</p>
<p>两种创建方式：</p>
<ul>
<li>​<code>pair&lt;type, type&gt; p(value1, value2);</code>​</li>
<li>​<code>pair&lt;type, type&gt; p = make_pair(value1, value2);</code>​</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-6-7-set-容器排序"><a href="#4-6-7-set-容器排序" class="headerlink" title="4.6.7 set 容器排序"></a>4.6.7 set 容器排序</h3><p>‍</p>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p>‍</p>
<p>在还未存放数据之前，确定好排序规则！</p>
<p>‍</p>
<p>示例一：set 存放内置数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123; <span class="keyword">return</span> v1 &gt; v2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定排序规则，从大到小</span></span><br><span class="line">	set&lt;<span class="type">int</span>, MyCompare&gt; s2;  <span class="comment">// 在还未存放数据之前，确定好排序规则！</span></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例二：set 存放自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 按照年龄进行排序，降序</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span> </span>&#123; <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：对于自定义数据类型，set 必须指定排序规则才可以插入数据</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="4-7-map-x2F-multimap-容器"><a href="#4-7-map-x2F-multimap-容器" class="headerlink" title="4.7 map&#x2F;multimap 容器"></a>4.7 map&#x2F;multimap 容器</h2><p>‍</p>
<p>map 简介：</p>
<ul>
<li>map 中所有元素都是 pair</li>
<li>pair 中第一个元素为 key（键值），起到索引作用，第二个元素为 value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p>‍</p>
<p>map 本质：</p>
<ul>
<li>map&#x2F;multimap 属于<strong>关联式容器</strong>，底层结构是用二叉树实现</li>
</ul>
<p>‍</p>
<p>map 优点：</p>
<ul>
<li>可以根据 key 值快速找到 value 值</li>
</ul>
<p>‍</p>
<p>map 和 multimap 区别：</p>
<ul>
<li>map 不允许容器中有重复 key 值元素</li>
<li>multimap 允许容器中有重复 key 值元素</li>
</ul>
<hr>
<p>‍</p>
<h3 id="4-7-1-map-构造和赋值"><a href="#4-7-1-map-构造和赋值" class="headerlink" title="4.7.1 map 构造和赋值"></a>4.7.1 map 构造和赋值</h3><p>‍</p>
<p>构造：</p>
<ul>
<li>​<code>map&lt;T1, T2&gt; mp;</code>​                                  &#x2F;&#x2F; map 默认构造函数</li>
<li>​<code>map(const map &amp;mp);</code>​                           &#x2F;&#x2F; 拷贝构造函数</li>
</ul>
<p>‍</p>
<p>赋值：</p>
<ul>
<li>​<code>map&amp; operator=(const map &amp;mp);</code>​         &#x2F;&#x2F; 重载等号操作符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)	cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;  <span class="comment">// 默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(m)</span></span>;  <span class="comment">// 拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m3;</span><br><span class="line">	m3 = m2;  <span class="comment">// 赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：map 中所有元素都是成对出现，插入数据时候要使用对组</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="4-7-2-map-大小和交换"><a href="#4-7-2-map-大小和交换" class="headerlink" title="4.7.2 map 大小和交换"></a>4.7.2 map 大小和交换</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>size();</code>​                  &#x2F;&#x2F; 返回容器中元素的数目</li>
<li>​<code>empty();</code>​                 &#x2F;&#x2F; 判断容器是否为空</li>
<li>​<code>swap(st);</code>​               &#x2F;&#x2F; 交换两个集合容器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)	cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())	cout &lt;&lt; <span class="string">&quot;m 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m 的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-7-3-map-插入和删除"><a href="#4-7-3-map-插入和删除" class="headerlink" title="4.7.3 map 插入和删除"></a>4.7.3 map 插入和删除</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>insert(elem);</code>​<strong>​                          ​</strong> &#x2F;&#x2F; 在容器中插入元素</li>
<li>​<code>clear();</code>​                                    &#x2F;&#x2F; 清除所有元素</li>
<li>​<code>erase(pos);</code>​                               &#x2F;&#x2F; 删除 pos 迭代器所指的元素，返回下一个元素的迭代器</li>
<li>​<code>erase(beg, end);</code>​                       &#x2F;&#x2F; 删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器</li>
<li>​<code>erase(key);</code>​                                &#x2F;&#x2F; 删除容器中值为 key 的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)	cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">// 第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">// 第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">// 第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">// 第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-7-4-map-查找和统计"><a href="#4-7-4-map-查找和统计" class="headerlink" title="4.7.4 map 查找和统计"></a>4.7.4 map 查找和统计</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>find(key);</code>​ <strong>​                       ​</strong>&#x2F;&#x2F; 查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();</li>
<li>​<code>count(key);</code>​ <strong>​                     ​</strong>&#x2F;&#x2F; 统计 key 的元素个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<h3 id="4-7-5-map-容器排序"><a href="#4-7-5-map-容器排序" class="headerlink" title="4.7.5 map 容器排序"></a>4.7.5 map 容器排序</h3><p>‍</p>
<p>主要技术点:</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123; <span class="keyword">return</span> v1 &gt; v2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)	cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：对于自定义数据类型，map 必须要指定排序规则，同 set 容器</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h1 id="5-函数对象"><a href="#5-函数对象" class="headerlink" title="5 函数对象"></a>5 函数对象</h1><p>概念：</p>
<ul>
<li>重载函数调用操作符的类，其对象常称为函数对象</li>
<li>函数对象使用重载的（）时，行为类似函数调用，也叫仿函数</li>
</ul>
<p>‍</p>
<p>本质：</p>
<p>函数对象（仿函数）是一个类，不是一个函数</p>
<p>‍</p>
<p>特点：</p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用， 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123; <span class="keyword">return</span> v1 + v2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>() &#123; count = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++;  <span class="comment">// 统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count;  <span class="comment">// 内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint 调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint&amp; mp , string test)</span>	</span>&#123; <span class="built_in">mp</span>(test); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint 调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="5-1-谓词"><a href="#5-1-谓词" class="headerlink" title="5.1 谓词"></a>5.1 谓词</h2><p>‍</p>
<p>概念：</p>
<ul>
<li>返回 bool 类型的仿函数称为谓词</li>
<li>如果 operator() 接受一个参数，那么叫做一元谓词</li>
<li>如果 operator() 接受两个参数，那么叫做二元谓词</li>
</ul>
<p>‍</p>
<p>一元谓词：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>二元谓词：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h2 id="5-2-内建函数对象"><a href="#5-2-内建函数对象" class="headerlink" title="5.2 内建函数对象"></a>5.2 内建函数对象</h2><p>概念：</p>
<ul>
<li>STL 内建了一些函数对象</li>
</ul>
<p>‍</p>
<p>分类：</p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p>‍</p>
<p>用法：</p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code>​</li>
</ul>
<hr>
<p>‍</p>
<h3 id="5-2-1-算术仿函数"><a href="#5-2-1-算术仿函数" class="headerlink" title="5.2.1 算术仿函数"></a>5.2.1 算术仿函数</h3><p>‍</p>
<p>功能描述：</p>
<ul>
<li>实现四则运算</li>
<li>其中 negate 是一元运算，其他都是二元运算</li>
</ul>
<p>‍</p>
<p>‍</p>
<p>仿函数原型：</p>
<ul>
<li>​<code>template&lt;class T&gt; T plus&lt;T&gt;</code>​               &#x2F;&#x2F; 加法仿函数</li>
<li>​<code>template&lt;class T&gt; T minus&lt;T&gt;</code>​             &#x2F;&#x2F; 减法仿函数</li>
<li>​<code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>​     &#x2F;&#x2F; 乘法仿函数</li>
<li>​<code>template&lt;class T&gt; T divides&lt;T&gt;</code>​          &#x2F;&#x2F; 除法仿函数</li>
<li>​<code>template&lt;class T&gt; T modulus&lt;T&gt;</code>​          &#x2F;&#x2F; 取模仿函数</li>
<li>​<code>template&lt;class T&gt; T negate&lt;T&gt;</code>​            &#x2F;&#x2F; 取反仿函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;  <span class="comment">// -50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code>​</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="5-2-2-关系仿函数"><a href="#5-2-2-关系仿函数" class="headerlink" title="5.2.2 关系仿函数"></a>5.2.2 关系仿函数</h3><p>‍</p>
<p>功能描述：</p>
<ul>
<li>实现关系对比</li>
</ul>
<p>‍</p>
<p>仿函数原型：</p>
<ul>
<li>​<code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>​                &#x2F;&#x2F; 等于</li>
<li>​<code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>​         &#x2F;&#x2F; 不等于</li>
<li>​<code>template&lt;class T&gt; bool greater&lt;T&gt;</code>​                  &#x2F;&#x2F; 大于</li>
<li>​<code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>​        &#x2F;&#x2F; 大于等于</li>
<li>​<code>template&lt;class T&gt; bool less&lt;T&gt;</code>​                        &#x2F;&#x2F; 小于</li>
<li>​<code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>​              &#x2F;&#x2F; 小于等于</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>	</span>&#123; <span class="keyword">return</span> v1 &gt; v2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自己实现仿函数</span></span><br><span class="line">	<span class="comment">// sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">// STL 内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：关系仿函数中最常用的就是 greater&lt;&gt; 大于</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="5-2-3-逻辑仿函数"><a href="#5-2-3-逻辑仿函数" class="headerlink" title="5.2.3 逻辑仿函数"></a>5.2.3 逻辑仿函数</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li>​<code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>​         &#x2F;&#x2F; 逻辑与</li>
<li>​<code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>​           &#x2F;&#x2F; 逻辑或</li>
<li>​<code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>​         &#x2F;&#x2F; 逻辑非</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 逻辑非  将 v 容器搬运到 v2 中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>‍</p>
<p>‍</p>
<h1 id="6-STL-常用算法"><a href="#6-STL-常用算法" class="headerlink" title="6 STL 常用算法"></a>6 STL 常用算法</h1><p>‍</p>
<p>概述：</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code>​ <code>&lt;functional&gt;</code>​ <code>&lt;numeric&gt;</code>​组成</li>
<li>​<code>&lt;algorithm&gt;</code>​是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li>​<code>&lt;numeric&gt;</code>​体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li>​<code>&lt;functional&gt;</code>​定义了一些模板类，用以声明函数对象</li>
</ul>
<hr>
<p>‍</p>
<h2 id="6-1-常用遍历算法"><a href="#6-1-常用遍历算法" class="headerlink" title="6.1 常用遍历算法"></a>6.1 常用遍历算法</h2><p>‍</p>
<p>算法简介：</p>
<ul>
<li>​<code>for_each</code>​                    &#x2F;&#x2F; 遍历容器</li>
<li>​<code>transform</code>​                  &#x2F;&#x2F; 搬运容器到另一个容器中</li>
</ul>
<hr>
<p>‍</p>
<h3 id="6-1-1-for-each"><a href="#6-1-1-for-each" class="headerlink" title="6.1.1 for_each"></a>6.1.1 for_each</h3><p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>for_each(iterator beg, iterator end, _func);</code>​</p>
<p>  &#x2F;&#x2F; 遍历算法遍历容器元素</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; _func 函数或者函数对象</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span>	</span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each 算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：for_each 在实际开发中是最常用遍历算法，需要熟练掌握</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-1-2-transform"><a href="#6-1-2-transform" class="headerlink" title="6.1.2 transform"></a>6.1.2 transform</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code>​</p>
<p>  &#x2F;&#x2F; beg1 源容器开始迭代器</p>
<p>  &#x2F;&#x2F; end1 源容器结束迭代器</p>
<p>  &#x2F;&#x2F; beg2 目标容器开始迭代器</p>
<p>  &#x2F;&#x2F; _func 函数或者函数对象</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用遍历算法  搬运 transform</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span>	</span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;  <span class="comment">// 目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());  <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());  <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h2 id="6-2-常用查找算法"><a href="#6-2-常用查找算法" class="headerlink" title="6.2 常用查找算法"></a>6.2 常用查找算法</h2><p>‍</p>
<p>算法简介：</p>
<ul>
<li>​<code>find</code>​                                  &#x2F;&#x2F; 查找元素</li>
<li>​<code>find_if</code>​                             &#x2F;&#x2F; 按条件查找元素</li>
<li>​<code>adjacent_find</code>​                   &#x2F;&#x2F; 查找相邻重复元素</li>
<li>​<code>binary_search</code>​                   &#x2F;&#x2F; 二分查找法</li>
<li>​<code>count</code>​                                 &#x2F;&#x2F; 统计元素个数</li>
<li>​<code>count_if</code>​                           &#x2F;&#x2F; 按条件统计元素个数</li>
</ul>
<hr>
<p>‍</p>
<h3 id="6-2-1-find"><a href="#6-2-1-find" class="headerlink" title="6.2.1 find"></a>6.2.1 find</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器 end()</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>find(iterator beg, iterator end, value);</code>​</p>
<p>  &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; value 查找的元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重载 ==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 利用 find 可以在容器中找指定的元素，返回值是迭代器</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-2-2-find-if"><a href="#6-2-2-find-if" class="headerlink" title="6.2.2 find_if"></a>6.2.2 find_if</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>按条件查找元素</li>
</ul>
<p>函数原型：</p>
<ul>
<li><p>​<code>find_if(iterator beg, iterator end, _Pred);</code>​</p>
<p>  &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; _Pred 函数或者谓词（返回 bool 类型的仿函数）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="keyword">return</span> val &gt; <span class="number">5</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person&amp; p)</span> </span>&#123; <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;  <span class="comment">// 找到姓名:ccc 年龄: 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：find_if 按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-2-3-adjacent-find"><a href="#6-2-3-adjacent-find" class="headerlink" title="6.2.3 adjacent_find"></a>6.2.3 adjacent_find</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>adjacent_find(iterator beg, iterator end);</code>​</p>
<p>  &#x2F;&#x2F; 查找相邻重复元素，返回相邻元素的第一个位置的迭代器</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())	cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：面试题中如果出现查找相邻重复元素，记得用 STL 中的 adjacent_find 算法</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-2-4-binary-search"><a href="#6-2-4-binary-search" class="headerlink" title="6.2.4 binary_search"></a>6.2.4 binary_search</h3><p>‍</p>
<p>二分查找功能：</p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>bool binary_search(iterator beg, iterator end, value);</code>​</p>
<p>  &#x2F;&#x2F; 查找指定的元素，查到 返回 true 否则 false</p>
<p>  &#x2F;&#x2F; 注意: 在无序序列中不可用</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; value 查找的元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="comment">// 二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)	cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-2-5-count"><a href="#6-2-5-count" class="headerlink" title="6.2.5 count"></a>6.2.5 count</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>统计元素个数</li>
</ul>
<p>函数原型：</p>
<ul>
<li><p>​<code>count(iterator beg, iterator end, value);</code>​</p>
<p>  &#x2F;&#x2F; 统计元素出现次数</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; value 统计的元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4 的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span>	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">  </span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	<span class="comment">// 注意重载运算符里的逻辑</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;  <span class="comment">// num = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结： 统计自定义数据类型时候，需要配合重载 ​</strong>​<code>**operator==**</code>​****</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-2-6-count-if"><a href="#6-2-6-count-if" class="headerlink" title="6.2.6 count_if"></a>6.2.6 count_if</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p>函数原型：</p>
<ul>
<li><p>​<code>count_if(iterator beg, iterator end, _Pred);</code>​</p>
<p>  &#x2F;&#x2F; 按条件统计元素出现次数</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; _Pred 谓词</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="keyword">return</span> val &gt;= <span class="number">4</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span> </span>&#123; <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：按<strong>值</strong>统计用 count，按<strong>条件</strong>统计用 count_if</p>
</blockquote>
<hr>
<p>‍</p>
<h2 id="6-3-常用排序算法"><a href="#6-3-常用排序算法" class="headerlink" title="6.3 常用排序算法"></a>6.3 常用排序算法</h2><p>‍</p>
<p>算法简介：</p>
<ul>
<li>​<code>sort</code>​                                                 &#x2F;&#x2F; 对容器内元素进行排序</li>
<li>​<code>random_shuffle</code>​                                &#x2F;&#x2F; 洗牌，指定范围内的元素随机调整次序</li>
<li>​<code>merge</code>​                                               &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li>
<li>​<code>reverse</code>​                                            &#x2F;&#x2F; 反转指定范围的元素</li>
</ul>
<hr>
<p>‍</p>
<h3 id="6-3-1-sort"><a href="#6-3-1-sort" class="headerlink" title="6.3.1 sort"></a>6.3.1 sort</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>sort(iterator beg, iterator end, _Pred);</code>​</p>
<p>  &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; _Pred 谓词</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort 默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：sort 属于开发中最常用的算法之一，需熟练掌握</p>
</blockquote>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-3-2-random-shuffle"><a href="#6-3-2-random-shuffle" class="headerlink" title="6.3.2 random_shuffle"></a>6.3.2 random_shuffle</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>洗牌，指定范围内的元素随机调整次序</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>random_shuffle(iterator beg, iterator end);</code>​</p>
<p>  &#x2F;&#x2F; 指定范围内的元素随机调整次序</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));  <span class="comment">// 记得加随机数种子</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)	v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：random_shuffle 洗牌算法比较实用，使用时记得加随机数种子</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-3-3-merge"><a href="#6-3-3-merge" class="headerlink" title="6.3.3 merge"></a>6.3.3 merge</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p>函数原型：</p>
<ul>
<li><p>​<code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>​</p>
<p>  &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</p>
<p>  &#x2F;&#x2F; 注意：两个容器必须是有序的</p>
<p>  &#x2F;&#x2F; beg1 容器 1 开始迭代器</p>
<p>  &#x2F;&#x2F; end1 容器 1 结束迭代器</p>
<p>  &#x2F;&#x2F; beg2 容器 2 开始迭代器</p>
<p>  &#x2F;&#x2F; end2 容器 2 结束迭代器</p>
<p>  &#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">// 合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：merge 合并的两个容器必须的有序序列</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-3-4-reverse"><a href="#6-3-4-reverse" class="headerlink" title="6.3.4 reverse"></a>6.3.4 reverse</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>reverse(iterator beg, iterator end);</code>​</p>
<p>  &#x2F;&#x2F; 反转指定范围的元素</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：reverse 反转区间内元素，面试题可能涉及到</p>
</blockquote>
<hr>
<p>‍</p>
<h2 id="6-4-常用拷贝和替换算法"><a href="#6-4-常用拷贝和替换算法" class="headerlink" title="6.4 常用拷贝和替换算法"></a>6.4 常用拷贝和替换算法</h2><p>‍</p>
<p>算法简介：</p>
<ul>
<li>​<code>copy</code>​                                                     &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li>
<li>​<code>replace</code>​                                                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li>
<li>​<code>replace_if&lt;span&gt; &lt;/span&gt;</code>​                   &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li>
<li>​<code>swap</code>​                                                      &#x2F;&#x2F; 互换两个容器的元素</li>
</ul>
<hr>
<p>‍</p>
<h3 id="6-4-1-copy"><a href="#6-4-1-copy" class="headerlink" title="6.4.1 copy"></a>6.4.1 copy</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>copy(iterator beg, iterator end, iterator dest);</code>​</p>
<p>  &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; dest 目标起始迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)	v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：利用 copy 算法在拷贝时，目标容器记得提前开辟空间</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-4-2-replace"><a href="#6-4-2-replace" class="headerlink" title="6.4.2 replace"></a>6.4.2 replace</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>replace(iterator beg, iterator end, oldvalue, newvalue);</code>​</p>
<p>  &#x2F;&#x2F; 将区间内旧元素 替换成 新元素</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; oldvalue 旧元素</p>
<p>  &#x2F;&#x2F; newvalue 新元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将容器中的 20 替换成 2000</span></span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：replace 会替换区间内满足条件的元素</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-4-3-replace-if"><a href="#6-4-3-replace-if" class="headerlink" title="6.4.3 replace_if"></a>6.4.3 replace_if</h3><p>‍</p>
<p>功能:</p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p>函数原型：</p>
<ul>
<li><p>​<code>replace_if(iterator beg, iterator end, _pred, newvalue);</code>​</p>
<p>  &#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; _pred 谓词</p>
<p>  &#x2F;&#x2F; newvalue 替换的新元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="keyword">return</span> val &gt;= <span class="number">30</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将容器中大于等于的 30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：replace_if 按条件查找，可以利用仿函数灵活筛选满足的条件</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-4-4-swap"><a href="#6-4-4-swap" class="headerlink" title="6.4.4 swap"></a>6.4.4 swap</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>swap(container c1, container c2);</code>​</p>
<p>  &#x2F;&#x2F; 互换两个容器的元素</p>
<p>  &#x2F;&#x2F; c1 容器 1</p>
<p>  &#x2F;&#x2F; c2 容器 2</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：swap 交换容器时，注意交换的容器要<strong>同种类型</strong></p>
</blockquote>
<hr>
<p>‍</p>
<h2 id="6-5-常用算术生成算法"><a href="#6-5-常用算术生成算法" class="headerlink" title="6.5 常用算术生成算法"></a>6.5 常用算术生成算法</h2><p>‍</p>
<p>注意：</p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code>​</li>
</ul>
<p>‍</p>
<p>算法简介：</p>
<ul>
<li>​<code>accumulate</code>​                    &#x2F;&#x2F; 计算容器元素累计总和</li>
<li>​<code>fill</code>​                               &#x2F;&#x2F; 向容器中添加元素</li>
</ul>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-5-1-accumulate"><a href="#6-5-1-accumulate" class="headerlink" title="6.5.1 accumulate"></a>6.5.1 accumulate</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>计算区间内容器元素累计总和</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>accumulate(iterator beg, iterator end, value);</code>​</p>
<p>  &#x2F;&#x2F; 计算容器元素累计总和</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; value 起始值</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)	v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：accumulate 使用时头文件注意是 numeric，这个算法很实用</p>
</blockquote>
<hr>
<p>‍</p>
<h3 id="6-5-2-fill"><a href="#6-5-2-fill" class="headerlink" title="6.5.2 fill"></a>6.5.2 fill</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>fill(iterator beg, iterator end, value);</code>​</p>
<p>  &#x2F;&#x2F; 向容器中填充元素</p>
<p>  &#x2F;&#x2F; beg 开始迭代器</p>
<p>  &#x2F;&#x2F; end 结束迭代器</p>
<p>  &#x2F;&#x2F; value 填充的值</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：利用​ fill ​可以将容器区间内元素填充为指定的值</p>
</blockquote>
<hr>
<p>‍</p>
<h2 id="6-6-常用集合算法"><a href="#6-6-常用集合算法" class="headerlink" title="6.6 常用集合算法"></a>6.6 常用集合算法</h2><p>‍</p>
<p>算法简介：</p>
<ul>
<li>​<code>set_intersection</code>​                               &#x2F;&#x2F; 求两个容器的交集</li>
<li>​<code>set_union</code>​                                           &#x2F;&#x2F; 求两个容器的并集</li>
<li>​<code>set_difference&lt;span&gt; &lt;/span&gt;</code>​          &#x2F;&#x2F; 求两个容器的差集</li>
</ul>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-6-1-set-intersection"><a href="#6-6-1-set-intersection" class="headerlink" title="6.6.1 set_intersection"></a>6.6.1 set_intersection</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>​</p>
<p>  &#x2F;&#x2F; 求两个集合的交集</p>
<p>  &#x2F;&#x2F; 注意：两个集合必须是有序序列</p>
<p>  &#x2F;&#x2F; beg1 容器 1 开始迭代器</p>
<p>  &#x2F;&#x2F; end1 容器 1 结束迭代器</p>
<p>  &#x2F;&#x2F; beg2 容器 2 开始迭代器</p>
<p>  &#x2F;&#x2F; end2 容器 2 结束迭代器</p>
<p>  &#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">// 取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：结束迭代器参数是 set_intersection 返回值，只有存放了交集个数个数量，开辟了空间但是没有存值的空间用 0 填充</span></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从两个容器中取小值</li>
<li>set_intersection 返回值既是交集中最后一个元素的位置</li>
</ul>
<hr>
<p>‍</p>
<h3 id="6-6-2-set-union"><a href="#6-6-2-set-union" class="headerlink" title="6.6.2 set_union"></a>6.6.2 set_union</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>​</p>
<p>  &#x2F;&#x2F; 求两个集合的并集</p>
<p>  &#x2F;&#x2F; 注意：两个集合必须是有序序列</p>
<p>  &#x2F;&#x2F; beg1 容器 1 开始迭代器</p>
<p>  &#x2F;&#x2F; end1 容器 1 结束迭代器</p>
<p>  &#x2F;&#x2F; beg2 容器 2 开始迭代器</p>
<p>  &#x2F;&#x2F; end2 容器 2 结束迭代器</p>
<p>  &#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">// 取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要两个容器相加</li>
<li>set_union 返回值既是并集中最后一个元素的位置</li>
</ul>
<hr>
<p>‍</p>
<p>‍</p>
<h3 id="6-6-3-set-difference"><a href="#6-6-3-set-difference" class="headerlink" title="6.6.3 set_difference"></a>6.6.3 set_difference</h3><p>‍</p>
<p>功能：</p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p>‍</p>
<p>函数原型：</p>
<ul>
<li><p>​<code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>​</p>
<p>  &#x2F;&#x2F; 求两个集合的差集</p>
<p>  &#x2F;&#x2F; 注意：两个集合必须是有序序列</p>
<p>  &#x2F;&#x2F; beg1 容器 1 开始迭代器</p>
<p>  &#x2F;&#x2F; end1 容器 1 结束迭代器</p>
<p>  &#x2F;&#x2F; beg2 容器 2 开始迭代器</p>
<p>  &#x2F;&#x2F; end2 容器 2 结束迭代器</p>
<p>  &#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">// 取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从两个容器取较大值</li>
<li>set_difference 返回值既是差集中最后一个元素的位置</li>
</ul>
<p>‍</p>
]]></content>
      <categories>
        <category>技术归纳</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
</search>
